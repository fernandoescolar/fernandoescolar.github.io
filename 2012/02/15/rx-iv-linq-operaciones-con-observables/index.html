<!DOCTYPE html>
<html lang="es-es">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
		<title>
			Rx IV – Linq: operaciones con observables · developerro
		</title>
		<!-- Social Metas -->
		<meta name="description" content="Hemos llegado al cuarto art&amp;iacute;culo sobre reactive extensions en el que vamos a hablar de operaciones que se pueden realizar con observables. Pero, como ..." />
		<meta property="og:title" content="Rx IV &#8211; Linq: operaciones con observables" />
		<meta property="og:type" content="article" />
		<meta property="og:url" content="https://www.developerro.com/2012/02/15/rx-iv-linq-operaciones-con-observables" />
		<meta property="og:image" content="https://www.developerro.com/assets/apple-touch-icon-144-precomposed.png" />
		<meta property="og:description" content="Hemos llegado al cuarto art&iacute;culo sobre reactive extensions en el que vamos a hablar de operaciones que se pueden realizar con observables. Pero, como ..." />
		<meta property="og:site_name" content="developerro" />
		<meta property="og:locale" content="es_es" />
		<meta property="article:modified_time" content="2012-02-15 10:15:08Z" />
		<meta property="article:published_time" content="2012-02-15 10:15:08Z" />
		<meta property="article:author" content="Fernando Escolar" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/24/azure-functions-net-5" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/10/efcore-vs-records" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/03/chorra-tip-1-wcd-command" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@fernandoescolar" />
		<meta name="twitter:creator" content="@fernandoescolar" />
		<meta name="twitter:title" content="Rx IV &#8211; Linq: operaciones con observables" />
		<meta name="twitter:description" content="Hemos llegado al cuarto art&iacute;culo sobre reactive extensions en el que vamos a hablar de operaciones que se pueden realizar con observables. Pero, como ..." />
		<meta name="twitter:image" content="https://www.developerro.com/assets/apple-touch-icon-144-precomposed.png" />
		<meta name="twitter:url" content="https://www.developerro.com/2012/02/15/rx-iv-linq-operaciones-con-observables" />
		<meta name="description" content="Hemos llegado al cuarto art&iacute;culo sobre reactive extensions en el que vamos a hablar de operaciones que se pueden realizar con observables. Pero, como ..." />
		<link rel="alternate" type="application/atom+xml" title="Developerro" href="/atom.xml" />
		<link rel="canonical" href="https://www.developerro.com/2012/02/15/rx-iv-linq-operaciones-con-observables" />
		<!-- Icons -->
		<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-144-precomposed.png" />
		<link rel="shortcut icon" href="/assets/favicon.ico" />
		<!-- RSS -->
		<link rel="alternate" type="application/rss+xml" title="Developerro" href="/atom.xml" />
		<!-- Styles -->
		<link href="https://fonts.googleapis.com/css?family=Lato:400,700" rel="stylesheet" type="text/css" />
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" type="text/css" />
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" type="text/css" />
		<link rel="stylesheet" href="/assets/vendor/fontawesome-free/css/all.min.css" />
		<link rel="stylesheet" href="/assets/main.css" />
		<link rel="stylesheet" href="/assets/syntax.css" />
		<!-- Analytics -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=UA-163390000-1">
		</script>
		<script>
			
			    function activateGoogleAnalytics() {
			        window.dataLayer = window.dataLayer || [];
			        function gtag(){dataLayer.push(arguments);}
			        gtag('js', new Date());
			        gtag('config', 'UA-163390000-1');
			    }
			
		</script>
	</head>
	<body>
		<nav>
			<i id="hamburger">
			</i> <a href="/">
				<b>
					d</b>eveloperro
			</a>
			<ul>
				<li>
					<a href="/posts">blog
					</a>
				</li>
				<li>
					<a href="/about">
						acerca de
					</a>
				</li>
				<li>
					<a href="/archive">
						archivo
					</a>
				</li>
				<li>
					<a href="/projects">
						oss
					</a>
				</li>
				<li>
					<a href="/search">
						buscar
					</a>
				</li>
				<li>
					<a href="/videos">
						vídeos
					</a>
				</li>
			</ul>
		</nav>
		<header class="post">
			<h1>
				Rx IV – Linq: operaciones con observables
			</h1><small>15 feb. 2012 · 16 min. de lectura
			</small>
		</header>
		<article class="post">
			<p>
				Hemos llegado al cuarto artículo sobre <strong>reactive extensions
				</strong> en el que vamos a hablar de operaciones que se pueden realizar con observables. Pero, como hace unos días que no publicábamos nada al respecto, vamos a hacer primero una pequeña retrospectiva. Hasta ahora hemos tratado de explicar <a href="/2011/12/12/rx-i-que-son-las-reactive-extensions" title="Rx I - Qu&eacute; son las Reactive eXtensions">rx como una fórmula matemática
				</a>:
			</p>
			<!--break-->
			<p style="align: center;">
				<img src="/assets/uploads/2012/09/rx-III-0.gif" alt="" width="370" height="150" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<p>
				Dentro de esta formula hemos intentado exponer que el componente básico son <a href="2011/12/19/rx-ii-observables-los-sujetos" title="Rx II - Observables: los sujetos">los sujetos
				</a> (observables), y también las <a href="/2012/01/02/rx-iii-linq-crear-objetos-observables" title="Rx III - Linq: crear objetos observables">operaciones básicas de creación
				</a> (linq). En este artículo explicaremos más a fondo el resto de operaciones y operadores que podemos encontrar.
			</p>
			<p>
				Pero antes de entrar en materia vamos a conocer unos diagramas que nos ayudarán a explicar y entender más fácilmente cómo se comportan las operaciones:
			</p>
			<h2>
				Marble diagrams
			</h2>
			<p>
				Cuando hablamos de <strong>reactive extensions
				</strong> es muy común encontrarnos con unos diagramas que nos ayudan a entender las operaciones. En ellos se muestra la evolución de la tarea de observación con respecto el tiempo y tienen este formato:
			</p>
			<center>
				<img src="/assets/uploads/2012/10/rx-iv-1.jpg" alt="" align="middle" width="400" height="192" />
			</center>
			<p>
				Dentro de uno de estos diagramas podemos encontrarnos con 4 símbolos diferentes:
			</p>
			<center>
				<div>
					<table class="table-bordered">
						<tbody>
							<tr>
								<td>
									●
								</td>
								<td>
									Representa una iteración o un valor en una secuencia observable. (IObserver&lt;T>.OnNext(T);)
								</td>
							</tr>
							<tr>
								<td>
									▲
								</td>
								<td>
									Cuando sucede una transformación en un valor.
								</td>
							</tr>
							<tr>
								<td>
									x
								</td>
								<td>
									Si una excepción termina con la secuencia observable. (IObserver&lt;T>.OnError(Exception);)
								</td>
							</tr>
							<tr>
								<td>
									|
								</td>
								<td>
									Cuando una secuencia observable termina de forma correcta. (IObserver&lt;T>.OnCompleted();)
								</td>
							</tr>
						</tbody>
					</table>
				</div>
			</center>
			<p>
				 
			</p>
			<p>
				Una vez tenemos claro cómo funciona, podemos ponernos a explicar los operadores especiales:
			</p>
			<h2>
				Merge
			</h2>
			<p>
				Cuando hacemos un Merge de dos objetos observables, estamos seleccionando todas las iteraciones (<em>OnNext
				</em>) de uno y otro operador.
			</p>
			<pre class="brush: csharp">var z = x.Merge(y);</pre>
			<p>
				En este ejemplo, el observable <em>z
				</em> terminará cuando se haya completado (<em>OnComplete
				</em>) tanto <em>x
				</em> como <em>y
				</em>, o cuando <strong>una de ellas tenga un error
				</strong> (<em>OnError
				</em>). Una vista del resultado en un diagrama sería:
			</p>
			<p>
				<img src="/assets/uploads/2012/10/rx-md-merge.png" alt="Rx Merge" width="404" height="152" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<h2>
				Concat
			</h2>
			<p>
				Otra operación es la concatenación. Donde el resultado no será exactamente el mismo que el de un merge.
			</p>
			<pre class="brush: csharp">var z = x.Concat(y);</pre>
			<p>
				Al concatenar el observable <em>x
				</em> con y, el resultado serán todas las iteraciones de <em>x
				</em> (<em>OnNext
				</em>), hasta que este se haya completado (<em>OnComplete
				</em>), y después toda las que ocurran en el observable <em>y
				</em>. Las iteraciones que ocurran en <em>y
				</em> mientras <em>x
				</em> no ha terminado serán ignoradas. Y si ocurre un error (<em>OnError
				</em>) en <em>x
				</em> se terminará <em>z
				</em> con el error. Es un concepto un tanto complejo, pero si echamos un vistazo a su diagrama se entiende rápidamente:
			</p>
			<p>
				<img src="/assets/uploads/2012/10/rx-md-concat.png" alt="Rx Concat" width="404" height="152" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<p>
				En un lenguaje más vulgar, se recogen la iteraciones de <em>x
				</em> y cuando termina, las de <em>y
				</em>.
			</p>
			<h2>
				Catch
			</h2>
			<p>
				Al igual que cuando hablamos de un bloque <em>try ... catch
				</em>, este operador recogerá un error (<em>OnError
				</em>) que se produzca en el primer operando:
			</p>
			<pre class="brush: csharp">var z = x.Catch(y);</pre>
			<p>
				Al poner esta secuencia, el resultado será semejante a un <em>Concat
				</em>. Pero la diferencia es que la "señal" que se utiliza para cambiar de 
				<br />
				operando es un error (OnError). Podemos decir entonces que se recogen todas las iteraciones (<em>OnNext
				</em>) de <em>x
				</em> hasta que este falla y entonces se empiezan a recoger las de <em>y
				</em>.
			</p>
			<p>
				<img src="/assets/uploads/2012/10/rx-md-catch.png" alt="Rx Catch" width="404" height="152" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<p>
				Si cualquiera de los dos operandos de la operación terminan (OnComplete) el resultado será que <em>z
				</em> también terminará.
			</p>
			<h2>
				OnErrorResumeNext
			</h2>
			<p>
				A la gente que ha programado en Visual basic, le sonará este comando. Como su buen nombre indica lo que hará es que si ocurre un error se pase al siguiente y si no seguirá con el proceso normal.
			</p>
			<pre class="brush: csharp">var z = x.OnErrorResumeNext(y);</pre>
			<p>
				Es decir, realizará la misma operación que un <em>Concat
				</em>, pero si encuentra un error se comportará como un <em>Catch
				</em>. O dicho con otras palabras, devuelve las iteraciones (<em>OnNext
				</em>) de <em>x
				</em>, hasta que ocurre un error (<em>OnError
				</em>) o es completado (<em>OnComplete
				</em>), momento en el cual empezará a devolver las iteraciones de <em>y
				</em>.
			</p>
			<p>
				<img src="/assets/uploads/2012/10/rx-md-onerrorresumenext.png" alt="Rx OnErrorResumeNext" width="404" height="152" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<h2>
				Zip
			</h2>
			<p>
				La operación <strong>Zip
				</strong> puede resultar un poco especial. Podríamos traducirla al castellano como "cremallera" y la operación que realiza se asemeja a lo que hace una cremallera al cerrarse. Si nos adentramos en este código:
			</p>
			<pre class="brush: csharp">var z = x.Zip(y, (oneX, oneY) => oneX + oneY);</pre>
			<p>
				El resultado esperará una iteración en alguno de los dos objetos observables. Cuando ocurra, esperará a que tenga una "respuesta" por parte del otro objeto observable. Es decir, va emparejando las iteraciones (<em>OnNext
				</em>) de uno y otro observable, aplicando la conversión que especifiquemos:
				<br />
				<br />
			</p>
			<p>
				<img src="/assets/uploads/2012/10/rx-mb-zip.png" alt="Rx Zip" align="middle" width="404" height="152" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<h2>
				CombineLatest
			</h2>
			<p>
				Una operación que se asemeja con <strong>Zip
				</strong> es <strong>CombineLatest
				</strong>. Como su nombre indica combinará las últimas iteraciones que se encuentra.
			</p>
			<pre class="brush: csharp">var z = x.CombineLatest(y, (oneX, oneY) => oneX + oneY);</pre>
			<p>
				Cuando nos encontremos este tipo de código, sabremos que cada vez que ocurre una iteración (OnNext) en alguno de los observables, la va a combinar con la última ocurrida en el otro observable, usando para ello la función que le hemos pasado como parámetro:
				<br />
				<br />
			</p>
			<p>
				<img src="/assets/uploads/2012/10/rx-md-combinelatest.png" alt="Rx CombineLatest" width="404" height="152" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<h2>
				Repeat
			</h2>
			<p>
				Teniendo en cuenta que un objeto observable de reactive extensions es además enumerable, puede ser que necesitemos repetir la última secuencia que hemos estado observando. En este contexto podríamos usar un código semejante a este:
			</p>
			<pre class="brush: csharp">var z = x.Repeat(3);</pre>
			<p>
				Donde grabaremos en el objeto observable <em>z
				</em> todas las iteraciones (<em>OnNext
				</em>) en orden, que han ocurrido en <em>x
				</em>, y las repetiremos tantas veces como le indiquemos (en este caso 3). Gráficamente se representaría así:
				<br />
				<br />
			</p>
			<p>
				<img src="/assets/uploads/2012/10/rx-md-repeat.png" alt="Rx Repeat" width="454" height="152" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<h2>
				Retry
			</h2>
			<p>
				Cuando lo que queremos es repetir la secuencia solo en el caso de que obtengamos un error (<em>OnError
				</em>), usaremos <strong>Retry
				</strong>.
			</p>
			<pre class="brush: csharp">var z = x.Retry(3);</pre>
			<p>
				Esta operación volverá a repetir la secuencia de iteraciones si se produce un error. Y lo intentará tantas veces como le indiquemos. Por supuesto que si no obtiene ningún error no se repetirá nunca la secuencia.
				<br />
				<br />
			</p>
			<p>
				<img src="/assets/uploads/2012/10/rx-md-retry.png" alt="Rx Retry" width="454" height="152" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<p>
			</p>
			<h2>
				Join
			</h2>
			<p>
				Hablar del método <strong>Join
				</strong> es lo mismo que hablar de unión entre dos objetos. Hasta este punto hemos visto dos formas de realizar "uniones" con objetos: <strong>Zip
				</strong> y <strong>CombineLatest
				</strong>. La diferencia fundamental de esta función es que no solo combina parejas o los últimos, si no más bien todas las posibles combinaciones hasta el momento de ocurrir.
			</p>
			<pre class="brush: csharp">var z = x.Join(y, v => x, v => y, (oneX, oneY) => oneX + oneY);</pre>
			<p>
				El formato en este caso es la unión entre x e <em>y
				</em>, mientras por un lado dure <em>x
				</em> (<em>v => x
				</em>) y por el otro dure <em>y
				</em>. Y la función de unión es la especificada en el último parámetro.
			</p>
			<p>
				Con el código que acabamos de ver, cada vez que ocurra una iteración (<em>OnNext
				</em>) buscará todas las iteraciones que han ocurrido en el otro observador y combinará esta con todas las anteriores. Un concepto que queda mucho más claro al ver el diagrama:
				<br />
				<br />
			</p>
			<p>
				<img src="/assets/uploads/2012/10/rx-md-join.png" alt="Rx Join" width="274" height="219" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<h2>
				Buffer
			</h2>
			<p>
				Uno de los métodos más útiles dentro de las rx, es el de <strong>Buffer
				</strong>, que nos permite crear bloques de observación en forma de listas genéricas, en dependencia del tiempo o de un número de iteraciones. Por ejemplo, imaginemos un escenario donde cada segundo recibimos una iteración, pero queremos agruparlas cada 3 segundos con el fin de que el usuario no vea refrescada constantemente la interfaz gráfica. En este caso podríamos usar este código:
			</p>
			<pre class="brush: csharp">var z = x.Buffer(TimeSpan.FromSeconds(3));</pre>
			<p>
				Y su resultado sería un objeto observable de este tipo: <strong>
					<em>
						IObservable&lt;IList&lt;T>></em>
				</strong>. O lo que es lo mismo, cada iteración de este nuevo objeto observable contendrá una lista de los objetos que se han almacenado en forma de buffer:
				<br /><img src="/assets/uploads/2012/10/rx-md-buffer-time.png" alt="Rx Buffer (time)" width="404" height="115" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<p>
				Como vemos en el ejemplo anterior, aunque en un segundo no se produzca una iteración, se guardará un buffer con respecto al tiempo. Si lo que deseamos es un resultado semejante a este:
			</p>
			<p>
				<img src="/assets/uploads/2012/10/rx-md-buffer-count.png" alt="Rx buffer (count)" width="404" height="115" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<p>
				Lo que tendremos que usar es también la función <strong>Buffer
				</strong>, pero esta vez con respecto a un contador (y no al tiempo):
			</p>
			<pre class="brush: csharp">var z = x.Buffer(3);</pre>
			<h2>
				Window
			</h2>
			<p>
				Muchos encontrarán que <strong>Window
				</strong> y <strong>Buffer
				</strong> tienen un formato semejante. En el caso de <strong>Buffer
				</strong> creamos una secuencia de paquetes en forma de lista genérica. Sin embargo, cuando usamos <strong>Window
				</strong>, en lugar de listas, empaquetamos en objetos observables.
			</p>
			<pre class="brush:">var z = x.Window(3);</pre>
			<p>
				En este caso el diagrama de <em>canicas
				</em> sería algo así:
			</p>
			<p>
				<img src="/assets/uploads/2012/10/rx-md-window-count.png" alt="Rx Window (Counter)" width="357" height="203" style="display: block; margin-left: auto; margin-right: auto;" />
			</p>
			<p>
				Por lo que el tipo de datos que devuelve esta función es <strong>
					<em>
						IObservable&lt;IObservable&lt;T>></em>
				</strong>. Y podemos usarlo con contador o con respecto el tiempo también:
			</p>
			<pre class="brush: csharp">var k = x.Window(TimeSpan.FromSeconds(3));</pre>
			<p>
				<br />
				<br />
			</p>
			<h2>
				Switch
			</h2>
			<p>
				Para terminar de describir métodos nuevos de las reactive extensions, hablaremos de <strong>Switch
				</strong>, que es complementario a <strong>Window
				</strong>, ya que realiza la operación contraria. Es decir, convierte un objeto <em>IObservable&lt;IObservable&lt;T>>
				</em> en un simple <strong>
					<em>
						IObservable&lt;T></em>
				</strong>.
			</p>
			<pre class="brush: csharp">IObservable&lt;int> x;
/* ... */

				<p>
					var k = x.Window(TimeSpan.FromSeconds(5));
				</p>

				<p>
					var w = k.Switch();
				</p></pre>
			<p>
				<br />
				En este código, haríamos que el objeto observable <em>x
				</em> fuera exactamente igual a <em>w
				</em>. Podríamos decir entonces que <strong>Switch
				</strong> es el equivalente al deshacer de un comando <strong>Window
				</strong>.
			</p>
			<p>
			</p>
			<h2>
				Aplicando Rx
			</h2>
			<p>
				La mejor de las virtudes de las reactive extensions, es su versatilidad. Puede aplicarse en muy diferentes escenarios y solo hay que dejar volar un poco la imaginación para darnos cuenta de que podemos usarlas para problemas comunes del día a día. Por ejemplo, hace unos meses, <strong>Pablo Nuñez
				</strong> (<a href="https://twitter.com/#!/pablonete" title="@pablonete" target="_blank">@pablonete
				</a>) propuso vía <strong>twitter
				</strong> un ejercicio simple de <strong>Linq
				</strong> que seguro nos hubiera ocupado unas cuantas líneas y gracias a rx podemos reducirlo a una:
			</p>
			<p>
				<i>
					Ejercicio LINQ: Trocear una lista { "a", "1", "b", "2", ...} en sublistas { { "a", "1" }, { "b", "2"}, {...}...}
				</i>
			</p>
			<p>
				La solución que podríamos deducir con lo estudiado hasta hora podría ser:
			</p>
			<pre class="brush: csharp">var list = new List&lt;string> { "1", "a", "2", "b", "3", "c", "4", "d", ... };
var result = new List&lt;List&lt;string>>();

				<p>
					list.ToObservable().Buffer(2).ObserveOn(Scheduler.Immediate).Subscribe(result.Add);
				</p></pre>
			<p>
				Esto no quiere decir que esta sea la mejor solución, solo una más. Lo que queremos dejar claro en este artículo es que <strong>reactive extensions son unas nuevas herramientas aplicables a la mayor parte de los escenarios que manejamos hoy en día
				</strong>. Nos aportan nuevas operaciones y por lo tanto más versatilidad al lenguaje y la plataforma de desarrollo que usamos.
				<br />
				<br />
			</p>
			<p>
				 
			</p>
			<p>
				 
			</p>
			<p>
				Antes de terminar, quisiera instar al lector a experimentar más métodos dentro de las extensiones de <strong>rx
				</strong>. Ya que aunque en este artículo hemos tratado muchos de ellos, no son los únicos. Y solo conociéndolos, descubriremos todas sus aplicaciones.
			</p>
			<p>
				Por hoy me despido y os invito a seguir esta línea de artículos, y más aún el siguiente donde de verdad la cosa se pone entretenida con la última variable de la función que nos definen las<strong> reactive extensions
				</strong>: <strong>Schedulers
				</strong>.
			</p>
		</article>
		<section id="share">
			<a href="https://twitter.com/intent/tweet?text=Rx IV &#8211; Linq: operaciones con observables&url=https://www.developerro.com/2012/02/15/rx-iv-linq-operaciones-con-observables" rel="nofollow" target="_blank" title="Share on Twitter">
				<i class="fab fa-twitter">
				</i>
			</a> <a href="https://facebook.com/sharer.php?u=https://www.developerro.com/2012/02/15/rx-iv-linq-operaciones-con-observables" rel="nofollow" target="_blank" title="Share on Facebook">
				<i class="fab fa-facebook"></i>
			</a> <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.developerro.com/2012/02/15/rx-iv-linq-operaciones-con-observables" rel="nofollow" target="_blank" title="Share on Linkedlin">
				<i class="fab fa-linkedin"></i>
			</a> <a href="http://www.reddit.com/submit?url=https://www.developerro.com/2012/02/15/rx-iv-linq-operaciones-con-observables" rel="nofollow" target="_blank" title="Share on Reddit">
				<i class="fab fa-reddit"></i>
			</a> <a href="https://www.buymeacoffee.com/fernandoescolar" rel="nofollow" target="_blank" title="Buy me a beer">
				<i class="fa fa-beer"></i> buy me a beer
			</a>
		</section>
		<section id="related">
			<h2>
				Relacionado (o no)
			</h2>
			<ul>
				<li>
					<a href="/2021/03/24/azure-functions-net-5">
						Azure Functions con .NET 5
					</a> <small>24 mar. 2021
					</small>
				</li>
				<li>
					<a href="/2021/03/10/efcore-vs-records">
						EF Core vs. Records
					</a> <small>10 mar. 2021
					</small>
				</li>
				<li>
					<a href="/2021/03/03/chorra-tip-1-wcd-command">
						ChorraTip: rutas windows en git bash
					</a> <small>03 mar. 2021
					</small>
				</li>
				<li>
					<a href="/video/2021/02/27/raiders-od-the-lost-leak">
						Raiders of the lost leak
					</a> <small>27 feb. 2021
					</small>
				</li>
				<li>
					<a href="/video/2020/12/09/net-5-just-talking">
						.Net 5 Just Talking
					</a> <small>09 dic. 2020
					</small>
				</li>
			</ul>
		</section>
		<footer>
			<ul>
				<li>
					<a href="mailto:fer.escolar@gmail.com" target="_blank">
						<i class="far fa-envelope">
						</i>
					</a>
				</li>
				<li>
					<a href="https://twitter.com/fernandoescolar" target="_blank">
						<i class="fab fa-twitter">
						</i>
					</a>
				</li>
				<li>
					<a href="https://www.linkedin.com/in/fernandoescolar" target="_blank">
						<i class="fab fa-linkedin">
						</i>
					</a>
				</li>
				<li>
					<a href="https://github.com/fernandoescolar" target="_blank">
						<i class="fab fa-github">
						</i>
					</a>
				</li>
				<li>
					<a href="https://www.buymeacoffee.com/fernandoescolar" target="_blank">
						<i class="fa fa-beer">
						</i>
					</a>
				</li>
			</ul><a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">
				<img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
			</a>
		</footer>
		<dialog id="cookie-notice">
			Nos gustaría usar cookies de terceros para hacer este sitio mejor. <a id="cookie-notice-accept">vale
			</a>
		</dialog>
		<script src="/assets/scripts.js">
		</script>
	</body>
</html>