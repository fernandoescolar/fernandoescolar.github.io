<!DOCTYPE html>
<html lang="es-es">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
		<title>
			Patrones de diseño: Singleton · developerro
		</title>
		<!-- Social Metas -->
		<meta name="description" content="Cuando hablamos de un patr&amp;oacute;n de dise&amp;ntilde;o nos referimos a una soluci&amp;oacute;n a un problema concreto en el desarrollo de software. Pero no cualqui..." />
		<meta property="og:title" content="Patrones de diseño: Singleton" />
		<meta property="og:type" content="article" />
		<meta property="og:url" content="https://www.developerro.com/2012/09/10/patrones-diseno-singleton" />
		<meta property="og:image" content="https://www.developerro.com/assets/apple-touch-icon-144-precomposed.png" />
		<meta property="og:description" content="Cuando hablamos de un patr&oacute;n de dise&ntilde;o nos referimos a una soluci&oacute;n a un problema concreto en el desarrollo de software. Pero no cualqui..." />
		<meta property="og:site_name" content="developerro" />
		<meta property="og:locale" content="es_es" />
		<meta property="article:modified_time" content="2012-09-10 13:06:17Z" />
		<meta property="article:published_time" content="2012-09-10 13:06:17Z" />
		<meta property="article:author" content="Fernando Escolar" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/24/azure-functions-net-5" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/10/efcore-vs-records" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/03/chorra-tip-1-wcd-command" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@fernandoescolar" />
		<meta name="twitter:creator" content="@fernandoescolar" />
		<meta name="twitter:title" content="Patrones de diseño: Singleton" />
		<meta name="twitter:description" content="Cuando hablamos de un patr&oacute;n de dise&ntilde;o nos referimos a una soluci&oacute;n a un problema concreto en el desarrollo de software. Pero no cualqui..." />
		<meta name="twitter:image" content="https://www.developerro.com/assets/apple-touch-icon-144-precomposed.png" />
		<meta name="twitter:url" content="https://www.developerro.com/2012/09/10/patrones-diseno-singleton" />
		<meta name="description" content="Cuando hablamos de un patr&oacute;n de dise&ntilde;o nos referimos a una soluci&oacute;n a un problema concreto en el desarrollo de software. Pero no cualqui..." />
		<link rel="alternate" type="application/atom+xml" title="Developerro" href="/atom.xml" />
		<link rel="canonical" href="https://www.developerro.com/2012/09/10/patrones-diseno-singleton" />
		<!-- Icons -->
		<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-144-precomposed.png" />
		<link rel="shortcut icon" href="/assets/favicon.ico" />
		<!-- RSS -->
		<link rel="alternate" type="application/rss+xml" title="Developerro" href="/atom.xml" />
		<!-- Styles -->
		<link href="https://fonts.googleapis.com/css?family=Lato:400,700" rel="stylesheet" type="text/css" />
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" type="text/css" />
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" type="text/css" />
		<link rel="stylesheet" href="/assets/vendor/fontawesome-free/css/all.min.css" />
		<link rel="stylesheet" href="/assets/main.css" />
		<link rel="stylesheet" href="/assets/syntax.css" />
		<!-- Analytics -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=UA-163390000-1">
		</script>
		<script>
			
			    function activateGoogleAnalytics() {
			        window.dataLayer = window.dataLayer || [];
			        function gtag(){dataLayer.push(arguments);}
			        gtag('js', new Date());
			        gtag('config', 'UA-163390000-1');
			    }
			
		</script>
	</head>
	<body>
		<nav>
			<i id="hamburger">
			</i> <a href="/">
				<b>
					d</b>eveloperro
			</a>
			<ul>
				<li>
					<a href="/posts">blog
					</a>
				</li>
				<li>
					<a href="/about">
						acerca de
					</a>
				</li>
				<li>
					<a href="/archive">
						archivo
					</a>
				</li>
				<li>
					<a href="/projects">
						oss
					</a>
				</li>
				<li>
					<a href="/search">
						buscar
					</a>
				</li>
				<li>
					<a href="/videos">
						vídeos
					</a>
				</li>
			</ul>
		</nav>
		<header class="post">
			<h1>
				Patrones de diseño: Singleton
			</h1><small>10 sept. 2012 · 12 min. de lectura
			</small>
		</header>
		<article class="post">
			<p>
				Cuando hablamos de un <strong>patrón de diseño nos referimos a una solución a un problema concreto en el desarrollo de software
				</strong>. Pero no cualquier solución, sólo aquellas que se ha desmostrado que <span style="text-decoration: underline;">son eficientes en diferentes escenarios
				</span> y <span style="text-decoration: underline;">reutilizables en gran cantidad de contextos
				</span> de aplicaciones. Por lo tanto, aunque los ejemplos que podamos dar estén en un lenguaje de programación concreto, la idea será extrapolable a diferentes lenguajes de programación orientada a objetos.
			</p>
			<!--break-->
			<h2>
				Singleton
			</h2>
			<p>
				El patrón singleton consiste en crear una instancia de un objeto y solo una, para toda nuestra aplicación. Sería como una especie de variable global que almacena nuestro objeto.
			</p>
			<p>
				En un primer momento esta definición puede sonar muy extraña. Por lo general, siempre se recomienda no usar variables globales en una aplicación, y mucho menos en programación orientada a objetos. Pero cuando hablamos de singleton, estamos jugando a crear una especie de variable global de forma encubierta. ¿Cómo puede ser esto un patrón?
			</p>
			<p>
				Para responder a esta pregunta vamos a proponeros dos escenarios diferentes:
			</p>
			<ul>
				<li>
					Piensa en una aplicación Web, que almacena en un objeto una serie de valores tipo parámetros de configuración. Estos parámetros son comunes para toda la aplicación. Se guardan en una base de datos y si son modificados por un administrador, quedan modificados para todos los usuarios que acceden a la página.
				</li>
			</ul>
			<ul>
				<li>
					Ahora vamos a imaginar que tenemos un recurso compartido como puede ser un fichero en el que escribimos un log de la aplicación. Este log puede ser accedido desde cualquier parte de la aplicación. Pero sabemos que un fichero no se puede abrir si otro proceso lo abrió anteriormente y aún no lo ha cerrado.
				</li>
			</ul>
			<p>
				Para ambos problemas podemos encontrar una solución usando el patrón singleton. Crearemos una especie de variable global, pero con unas características concretas:
			</p>
			<ul>
				<li>
					solo se puede instanciar una vez (single-instance)
				</li>
				<li>
					no se debe instanciar si nunca fue utilizada 
				</li>
				<li>
					es thread-safe, que quiere decir que sus métodos son accesibles desde diferentes hilos de ejecución, sin crear bloqueos ni excepciones debido a la concurrencia
				</li>
				<li>
					no tiene un constructor público, luego el objeto que la usa no puede instanciarla directamente
				</li>
				<li>
					posee un mecanismo para acceder a la instancia que se ha creado (mediante una propiedad estática, por ejemplo)
				</li>
			</ul>
			<p>
				Teniendo en cuenta estas características vamos a desarrollar una clase singleton:
			</p>
			<div id="CodeDiv" dir="ltr">
				<pre class="brush: csharp">public sealed class Singleton
{
    private static Singleton instance;

					<pre>
						<code>
							private Singleton()
{
}

public static Singleton Instance
{
    get
    {
        if (instance == null) instance = new Singleton();
        return instance;
    }
}

						</code></pre>

					<p>
						}
					</p></pre>
			</div>
			<p>
				En esta pequeña porción de código hemos conseguido realizar una única instancia en el momento en el que se llama por primera vez. Además hemos creado un constructor con acceso privado para que nadie pueda instanciar la clase. Y para terminar hemos creado una propiedad de solo lectura con la que se puede acceder a la instancia creada. Pero ésta no será Thread-safe. Para conseguirlo podríamos modificar la clase de la siguiente forma:
			</p>
			<div id="CodeDiv" dir="ltr">
				<pre class="brush: csharp">public sealed class Singleton
{
    private static readonly Singleton instance = new Singleton();

					<pre>
						<code>
							private Singleton() { }

public static Singleton Instance { get { return instance; } }

						</code></pre>

					<p>
						}
					</p></pre>
			</div>
			<p>
				Al crear el atributo que almacena la instancia como readonly, y al ser estática, se instanciará al arrancar la aplicación. Así conseguiremos que sea una clase thread-safe. Es decir, que no habrá problemas si varios procesos acceden a esta clase al mismo tiempo. No obstante, si quisieramos respetar que solo se instanciara el objeto bajo demanda, deberíamos usar bloqueos:
			</p>
			<div id="CodeDiv" dir="ltr">
				<pre class="brush: csharp">public sealed class Singleton
{
    private static readonly object locker = new object();
    private static volatile Singleton instance;

					<pre>
						<code>
							private Singleton() { }

public static Singleton Instance
{
    get
    {
        if (instance == null)
        {
            lock (locker)
            {
                if (instance == null) instance = new Singleton();
            }
        }

        return instance;
    }
}

						</code></pre>

					<p>
						}
					</p></pre>
			</div>
			<p>
				Gracias al bloqueo ya podremos ejecutar nuestra clase singleton en un contexto multihilo, instanciándola sólo cuando se ha solicitado la primera vez. A este efecto de carga en diferido se le denomina en inglés "Lazy Loading". Y desde la versión 4.0 de la framework .net se nos provee un objeto que nos ayuda a realizarla: Lazy. Por lo que podríamos simplificar nuestro ejemplo usándolo:
			</p>
			<div id="CodeDiv" dir="ltr">
				<pre class="brush: csharp">public sealed class Singleton
{
    private static readonly Lazy&lt;Singleton> instance = new Lazy&lt;Singleton>(() => new Singleton());

					<pre>
						<code>
							private Singleton() { }

public static Singleton Instance
{
    get
    {
        return instance.Value;
    }
}

						</code></pre>

					<p>
						}
					</p></pre>
			</div>
			<p>
				El objeto Lazy ya es de por si thread-safe y en su declaración simplemente debemos indicarle de qué forma se debe instanciar el objeto que contiene. Por esta razón es posiblemente la mejor implementación del patrón singleton.
			</p>
			<p>
				Si por ejemplo estuvieramos desarrollando la herramientas de log de nuestra aplicación, bastaría con que añadieramos las funciones necesarias para escribir en el log a nuestra clase singleton:
			</p>
			<div id="CodeDiv" dir="ltr">
				<pre class="brush: csharp">public sealed class Logger
{
    private static readonly Lazy&lt;Logger> instance = new Lazy&lt;Logger>(() => new Logger());

					<pre>
						<code>
							private Logger() { }

public static Logger Current
{
    get
    {
        return instance.Value;
    }
}

public void WriteInformation(string message)
{
   // ...
}

public void WriteWarning(string message)
{
   // ...
}

public void WriteError(string message)
{
   // ...
}

						</code></pre>

					<p>
						}
					</p></pre>
			</div>
			<p>
				Viendo este código en nuestra aplicación, está claro que para poder escribir en el log desde cualquier punto de la misma sólo tendremos que hacer esta llamada:
			</p>
			<div id="CodeDiv" dir="ltr">
				<pre class="brush: csharp">Logger.Current.WriteInformation("Una información");
Logger.Current.WriteWarning("Un aviso");
Logger.Current.WriteError("Un error");</pre>
			</div>
			<p>
				Al pararnos a pensar las consecuencias de escribir este código, caeremos en la cuenta de que singleton nos está creando una dependencia en todo el programa donde queramos tener información del proceso en forma de logs (eso es a lo largo de toda la aplicación). Algo que comunmente conocemos como <strong>acoplamiento entre clases
				</strong>.
			</p>
			<p>
				El acoplamiento puede dar varios problemas a lo largo del ciclo de vida de un software. Como por ejemplo a la hora de realizar pruebas unitarias. Pero no es objeto de este artículo centrarse en este problema. Aunque si lo es proponer soluciones de implementación del patrón singleton que se adapten a un desarrollo sólido.
			</p>
			<p>
				Si quisieramos evitar este acoplamiento, es recomendable usar un IoC Container (Inversion Of Control Container) para respetar la "D" de los pincipios <strong>SOLID
				</strong>: <strong>Dependency Inversion Principle
				</strong>. Esta, por así llamarla, norma nos dice que<strong> debemos depender de las abstraciones (las interfaces, los contratos) no de las concreciones (clases que implementan esas interfaces
				</strong>). 
			</p>
			<p>
				En las frameworks de inversión de control más conocidas se han implementado mecanismos que nos permiten crear objetos singleton desde el propio contenedor. Esto quiere decir que simplemente tendríamos que crear una interfaz y una implementación de la misma, sin preocuparnos de como se intancia. Visto en forma de código sería esto:
			</p>
			<div id="CodeDiv" dir="ltr">
				<div id="CodeDiv" dir="ltr">
					<pre class="brush: csharp">public interface ILogger
{
    void WriteInformation(string message);
    void WriteWarning(string message);
    void WriteError(string message);
}

						<p>
							public class Logger : ILogger
{
public Logger()
{
// ...
}
public void WriteInformation(string message)
{
// ...
}
public void WriteWarning(string message)
{
// ...
}
public void WriteError(string message)
{
// ...
}
}
						</p></pre>
				</div>
				<p>
					De esta forma, delegaríamos la gestión del ciclo de vida de las instancias al IoC Container que hayamos decidido. A continuación mostraremos cómo podemos configurar una instancia singleton usando las frameworks de inyección de dependencias (DI) más conocidas:
				</p>
				<ul>
					<li>
						Usando <strong>Structure maps
						</strong>:
					</li>
				</ul>
				<div id="CodeDiv" dir="ltr">
					<pre class="brush: csharp">// configurar
ObjectFactory.Initialize(x =>
{
    x.For&lt;ILogger>().Singleton().Use&lt;Logger>();
}
// recoger valor
var x = ObjectFactory.GetInstance&lt;ILogger>();</pre>
				</div>
				<ul>
					<li>
						Con <strong>Ninject
						</strong>:
					</li>
				</ul>
				<div id="CodeDiv" dir="ltr">
					<div id="CodeDiv" dir="ltr">
						<pre class="brush: csharp">// configurar
IKernel ninject = new StandardKernel(new InlineModule(
              x => x.Bind&lt;ILogger>().To&lt;Logger>(),
              x => x.Bind&lt;Logger>().ToSelf().InSingletonScope()));
// recoger valor
var x = ninject.Get&lt;ILogger>();</pre>
					</div>
				</div>
				<ul>
					<li>
						Con <strong>Unity
						</strong>:
					</li>
				</ul>
				<div id="CodeDiv" dir="ltr">
					<pre class="brush: csharp">// configurar
IUnityContainer container = new UnityContainer();
container.RegisterType&lt;ILogger, Logger>(new ContainerControlledLifetimeManager());
// recoger valor
var x = container.Resolve&lt;ILogger>();</pre>
				</div>
				<ul>
					<li>
						O con <b>autofact
						</b>:
					</li>
				</ul>
				<div id="CodeDiv" dir="ltr">
					<pre class="brush: csharp">var builder = new ContainerBuilder();
builder
   .Register(c => new Logger())
   .As&lt;ilogger>()
   .SingleInstance();
var container = builder.Build(); 
var x = container.Resolve&lt;ilogger>();</pre>
				</div>
				<p>
					Pero esto no quiere decir que no nos sirva la implementación de singleton que hicimos anteriormente, ya que es posible que no nos fiemos o que nuestro contenedor no tenga ningún artefacto que nos facilite la implementación singleton. Para estos casos, podríamos hacer que un contenedor como Unity nos devolviera la instancia singleton que gestiona nuestra clase usando la propiedad estática. Simplemente tendríamos que seguir usando una interface, implementarla en nuestra clase singleton y registrar una instancia en lugar de una clase en el contenedor:
				</p>
				<div id="CodeDiv" dir="ltr">
					<pre class="brush: csharp">public interface ILogger
{
    void WriteInformation(string message);
    void WriteWarning(string message);
    void WriteError(string message);
}

						<p>
							public sealed class Logger : ILogger
{
private static readonly Lazy&lt;Logger> instance = new Lazy&lt;Logger>(() => new Logger());
						</p>

						<pre>
							<code>
								private Logger() { }

public static Logger Current
{
    get
    {
        return instance.Value;
    }
}

public Logger()
{ 
    // ...
}
public void WriteInformation(string message)
{
    // ...
}
public void WriteWarning(string message)
{
    // ...
}
public void WriteError(string message)
{
    // ...
}

							</code></pre>

						<p>
							}
						</p></pre>
				</div>
				<p>
					De esta forma, por ejemplo, si usamos el contenedor de <strong>Unity
					</strong>, tendríamos que registrar su valor así:
				</p>
				<div id="CodeDiv" dir="ltr">
					<pre class="brush: csharp">var container = new UnityContainer();
container.RegisterInstance&lt;ILogger>(Logger.Current);</pre>
				</div>
				<p>
					Con este código sería nuestro singleton Logger quien gestione el ciclo de vida y conseguiríamos desacoplarnos de la implementación gracias al IoC.
					<br />
					<br />
					Podríamos hacer lo mismo con <strong>Structure maps
					</strong>:
				</p>
				<div id="CodeDiv" dir="ltr">
					<pre class="brush: csharp">ObjectFactory.Initialize(x =>
{
    x.For&lt;ILogger>().Use(Logger.Current);
}

						<p>
							var x = ObjectFactory.GetInstance&lt;ILogger>();
						</p></pre>
				</div>
				<p>
					Y para finalizar, con <strong>Ninject
					</strong>:
				</p>
				<div id="CodeDiv" dir="ltr">
					<pre class="brush: csharp">IKernel ninject = new StandardKernel(new InlineModule(
              x => x.Bind&lt;ILogger>().ToConstant(Logger.Current)));

						<p>
							var x = ninject.Get&lt;ILogger>();
						</p></pre>
				</div>
				<p>
					 
				</p>
				<p>
					A lo largo de este artículo hemos visto diferentes formas de implementar el patrón singleton. Un patrón de desarrollo sigue siendo vigente y válido. Lo único que tenemos que tener en cuenta, es evitar aplicarlo donde no corresponde o de una forma incorrecta. Algo que conocemos como el <strong>antipatrón singletonitis
					</strong>.
					<br />
					<br />
					<br />
				</p>
			</div>
		</article>
		<section id="share">
			<a href="https://twitter.com/intent/tweet?text=Patrones de diseño: Singleton&url=https://www.developerro.com/2012/09/10/patrones-diseno-singleton" rel="nofollow" target="_blank" title="Share on Twitter">
				<i class="fab fa-twitter">
				</i>
			</a> <a href="https://facebook.com/sharer.php?u=https://www.developerro.com/2012/09/10/patrones-diseno-singleton" rel="nofollow" target="_blank" title="Share on Facebook">
				<i class="fab fa-facebook"></i>
			</a> <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.developerro.com/2012/09/10/patrones-diseno-singleton" rel="nofollow" target="_blank" title="Share on Linkedlin">
				<i class="fab fa-linkedin"></i>
			</a> <a href="http://www.reddit.com/submit?url=https://www.developerro.com/2012/09/10/patrones-diseno-singleton" rel="nofollow" target="_blank" title="Share on Reddit">
				<i class="fab fa-reddit"></i>
			</a> <a href="https://www.buymeacoffee.com/fernandoescolar" rel="nofollow" target="_blank" title="Buy me a beer">
				<i class="fa fa-beer"></i> buy me a beer
			</a>
		</section>
		<section id="related">
			<h2>
				Relacionado (o no)
			</h2>
			<ul>
				<li>
					<a href="/2021/03/24/azure-functions-net-5">
						Azure Functions con .NET 5
					</a> <small>24 mar. 2021
					</small>
				</li>
				<li>
					<a href="/2021/03/10/efcore-vs-records">
						EF Core vs. Records
					</a> <small>10 mar. 2021
					</small>
				</li>
				<li>
					<a href="/2021/03/03/chorra-tip-1-wcd-command">
						ChorraTip: rutas windows en git bash
					</a> <small>03 mar. 2021
					</small>
				</li>
				<li>
					<a href="/video/2021/02/27/raiders-od-the-lost-leak">
						Raiders of the lost leak
					</a> <small>27 feb. 2021
					</small>
				</li>
				<li>
					<a href="/video/2020/12/09/net-5-just-talking">
						.Net 5 Just Talking
					</a> <small>09 dic. 2020
					</small>
				</li>
			</ul>
		</section>
		<footer>
			<ul>
				<li>
					<a href="mailto:fer.escolar@gmail.com" target="_blank">
						<i class="far fa-envelope">
						</i>
					</a>
				</li>
				<li>
					<a href="https://twitter.com/fernandoescolar" target="_blank">
						<i class="fab fa-twitter">
						</i>
					</a>
				</li>
				<li>
					<a href="https://www.linkedin.com/in/fernandoescolar" target="_blank">
						<i class="fab fa-linkedin">
						</i>
					</a>
				</li>
				<li>
					<a href="https://github.com/fernandoescolar" target="_blank">
						<i class="fab fa-github">
						</i>
					</a>
				</li>
				<li>
					<a href="https://www.buymeacoffee.com/fernandoescolar" target="_blank">
						<i class="fa fa-beer">
						</i>
					</a>
				</li>
			</ul><a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">
				<img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
			</a>
		</footer>
		<dialog id="cookie-notice">
			Nos gustaría usar cookies de terceros para hacer este sitio mejor. <a id="cookie-notice-accept">vale
			</a>
		</dialog>
		<script src="/assets/scripts.js">
		</script>
	</body>
</html>