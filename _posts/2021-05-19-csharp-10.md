---
published: true
ID: 202105191
title: 'Novedades de c# 10'
author: fernandoescolar
post_date: 2021-05-19 01:05:31
layout: post
tags: csharp dotnet novedades
background: '/assets/uploads/bg/programming5.jpg'
---

Hace unos días [Microsoft anunció Visual Studio 2022](https://devblogs.microsoft.com/visualstudio/visual-studio-2022/). La herramienta que viene a actualizar al ya vetusto Visual Studio 2019 (dos años en el mundo de la tecnología son una eternidad). No han indicado fecha exacta de lanzamiento. Dicen que podremos probarlo en verano. Quizá lo publiquen junto con .Net 6 en noviembre. Y si sacan nueva versión de IDE y de framework, suponemos que también aparecerá nueva versión de C#<!--break-->.

¿Lo llamarán **C# X**? ¿O se decantarán por un nombre menos dinámico y más aburrido como **C# 10**?

Lo que sí que sabemos es que, con cada versión nueva de nuestro lenguaje de programación favorito, tenemos nuevo artículo de análisis. De análisis y evaluación. Y para ello usaremos la famosa escala sexy-loca.

![escala sexy loca](/assets/uploads/2016/11/hot_crazy.jpg)

Las normas de puntuación son las habituales:
- En el eje vertical encontraremos lo útil que nos resulta la nueva funcionalidad.
- En el eje horizontal el grado de locura de la implementación.
- Consideraremos una característica como buena cuando se encuentr por encima de _la diagonal Vicky Mendoza_ (x=y).

## Global Using

```csharp
// Imports.cs
global using System;
global using static Developerro.Constants;
global using Alias = Developerro.MyClass;
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>7</b></p>
> <p>Crazy  = <b>3</b></p>

## Constant interpolated strings

```csharp
const string s1 = $"abc";
const string s2 = $"{s1}edf";
```

```csharp
const string pi = $"{3.14}}";
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>8</b></p>
> <p>Crazy  = <b>5</b></p>

## Record structs

```csharp
pulbic record struct MyRecordStruct(int Id, string Name);
pulbic record class MyRecordClass1(int Id, string Name);
pulbic record MyRecordClass2(int Id, string Name);
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>5</b></p>
> <p>Crazy  = <b>5</b></p>

## Static abstract members in interfaces

```csharp
interface IAddable<T> where T : IAddable<T>
{
  static abstract T Zero { get; }
  static abstract T operator +(T t1, T t2);
}
struct Int32 : ..., IAddable<Int32>
{
    static Int32 I.operator +(Int32 x, Int32 y) => x + y; // Explicit
    public static int Zero => 0;                          // Implicit
}
```

```csharp
public interface IAsyncFactory<T>
{
  abstract static Task<T> CreateAsync();
}
```

```csharp
public interface IVar
{
  string DefaultInstanceProperty => "instanceProperty";
  static string DefaultStaticProperty => "staticProperty";
}

class MyGenericClass<TVar> where TVar : class, IVar
{
  public MyGenericClass(TVar var)
  {
    _ = var.DefaultInstanceProperty;
    _ = TVar.DefaultStaticProperty;
  }
}
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>7</b></p>
> <p>Crazy  = <b>9</b></p>

## File scoped namespaces

```csharp
using System;

namespace Company.Project
{
  public class Product
  {
    ...
  }
}
```

```csharp
namespace Company.Project
using System;

public class Product
{
    ...
}
```

```csharp
using System;
namespace Company;
namespace Project;
public class Product { }
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>7</b></p>
> <p>Crazy  = <b>1</b></p>

## Lambda improvements

```csharp
app.MapAction([HttpGet("/")] () => new Todo(Id: 0, Name: "Name"));
app.MapAction([HttpPost("/")] ([FromBody] Todo todo) => todo);
```
### Allow lambdas with attributes

### Allow lambdas with explicit return type

```csharp
var f4 = () => 1;              // System.Func<int>
var f5 = () : string => null;  // System.Func<string>
```

### Infer a natural delegate type for lambdas and method groups

```csharp
Delegate d1 = 1.GetHashCode;
object o1 = (int x) => x;
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>10</b></p>
> <p>Crazy  = <b>10</b></p>

## Allow Generic Attributes

```csharp
public class GenericClass<T>
{
  [SomeAttribute<T>]
  public void DoSomething(T input)
  {
  }
}

public class SomeAttribute<T> : Attribute
{
}
```

```csharp
[ProducesResponseType<TEntity>(200)]
[ProducesResponseType(400)]
public virtual Task<IActionResult> GetById(int id)
{
```

`IActionResult<T>`

is that attribute arguments of type System.Type are stored as serialized strings containing the assembly-qualified name. What string can be deserialized (similar to Type.GetType) in such a way that it resolves to a generic type parameter?

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>8</b></p>
> <p>Crazy  = <b>7</b></p>

## Deconstruction improvements

### Mix Declarations and Variables

```csharp
Err err;
Ret1 ret1;
(ret1, err) = await Func1();
if (err) return (default, err);

Ret2 ret2;
(ret2, err) = await Func1();
if (err) return (default, err);
```

```csharp
Err err;
(var ret1, err) = await Func1();
if (err) return (default, err);

(var ret2, err) = await Func1();
if (err) return (default, err);
```

### Defaul deconstruction

```csharp
(int i, string j) = default;
```

`(default, default)`

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>6</b></p>
> <p>Crazy  = <b>3</b></p>

## List patterns

```csharp
collection switch
{
   { 1, 2, 3, .., 5 } => ... // causes start buffer to hold 3 elements
   {1,  .., 3, 4, 5 } => ... // causes end buffer to hold 3 elements
}
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>4</b></p>
> <p>Crazy  = <b>8</b></p>

## Property-Scoped Fields

```csharp
public string MyProperty
{
  get { return field; }
  set
  {
    field = value;
    NotifyOfPropertyChange(nameof(MyProperty));
  }
}
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>6</b></p>
> <p>Crazy  = <b>7</b></p>

## Required Properties

```csharp
public string Foo { get; required set; }
public string Bar { get; required init; }
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>5</b></p>
> <p>Crazy  = <b>8</b></p>

## Conclusiones

![resultados escala sexy-loca](/assets/uploads/2021/05/csharp-10.png)

https://github.com/dotnet/roslyn/blob/main/docs/Language%20Feature%20Status.md

https://github.com/dotnet/csharplang/milestone/19