---
published: true
ID: 202105191
title: 'Novedades de c# 10'
author: fernandoescolar
post_date: 2021-05-19 01:05:31
layout: post
tags: csharp dotnet novedades
background: '/assets/uploads/bg/programming5.jpg'
---

Hace unos días [Microsoft anunció Visual Studio 2022](https://devblogs.microsoft.com/visualstudio/visual-studio-2022/). La herramienta que viene a actualizar al ya vetusto Visual Studio 2019 (dos años en el mundo de la tecnología son una eternidad). Dicen que podremos probarlo en verano, pero no han indicado fecha exacta de lanzamiento. Quizá lo publiquen junto con .Net 6 en noviembre. Y si sacan nueva versión de IDE y de framework, tendrán nueva versión de C#<!--break-->. Digo yo...

¿Lo llamarán **C# X**? ¿O se decantarán por un nombre menos dinámico y más aburrido como **C# 10**?

Lo que sí que sabemos es que, con cada versión nueva de nuestro lenguaje de programación favorito, tenemos nuevo artículo de análisis. De análisis y evaluación. Y para ello usaremos la famosa escala sexy-loca.

![escala sexy loca](/assets/uploads/2016/11/hot_crazy.jpg)

Las normas de puntuación son las habituales:

- En el eje vertical encontraremos lo útil que nos resulta la nueva funcionalidad.
- En el eje horizontal el grado de locura de la implementación.
- Consideraremos una característica como buena cuando se encuentr por encima de _la diagonal Vicky Mendoza_ (x=y).

> Este año nos hemos adelantado un poco, así que algunas de estas funcionalidades no llegarán a aparecer y otras podrían llegar a publicarse, pero de una forma diferente a la que vamos a exponer.

## Global Using

Imagínate poder crear un archivo dentro de tu aplicación donde declaras las clausulas `using` que vas a usar a lo largo de tu código fuente. Una declaración global que referenciaciaría paquetes sin necesidad de hacerlo en cada uno de los archivos de código fuente. Esa es la idea de `global using`:

```csharp
// Imports.cs
global using System;
global using static Developerro.Constants;
global using Alias = Developerro.MyClass;
```

Si declaramos usa referencia, un conjunto de variables o un alias de forma global, estará disponible a lo largo de todo el código fuente del proyecto sin necesidad de tener que volver a referenciarlo archivo a archivo.

Con esta caracterítica he de adminitir que limipiría muchos `using` de al principio de muchos archivos. De esta manera podemos ganar visibilidad del código fuente. También quedarían más evidentes todas las dependencias al estar juntas en un solo lugar. Y si no nos interesa y queremos seguir referenciando paquetes en cada fichero, solo tenemos que ignorar que existe.

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>7</b></p>
> <p>Crazy  = <b>3</b></p>

## Constant interpolated strings

Las cadenas de texto interpoladas han añadio a C# la cabacidad de escribir la línea de código más elegante que he encontrado en mi carrera:

```csharp
var wtf = $@"%!&#";
```

La unión perfecta entre una viñeta de Ibañez y la programación.

Esta característica va de poder realizar este tipo de asignación en una variable constante, y ya que estamos realizar composición:

```csharp
const string baseUrl = $"https://www.developerro.com";
const string blogUrl = $"{baseUrl}/blog";
const string videosUrl = $"{baseUrl}/videos";
```

Una funcionalidad que a muchos nos ayudaría. Pero hay que tener en cuenta un problema. Si por ejemplo definimos:

```csharp
const string pi = $"{3.14}}";
```

Da la casualidad de que no sería un valor constante. 

Quizá debería dar error. Cuando convertimos un valor numérico con decimales a una cadena de texto, esta usa la cultura actual para dar formato al número. Por ejemplo, ese código en un ordenador con cultura española escribiría `"3,14"` pero con cultura inglesa `"3.14"`. Así que ¿cual sería la cultura para crear esta constante? El caso es que hoy en día, este hecho, tiene que afectar al factor *Crazy* de nuestra valoración.

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>8</b></p>
> <p>Crazy  = <b>5</b></p>

## Record structs

El tipo `record` fue la funcionalidad estrella de C# 9. Es normal que se quiera extender su uso para objetos de tipo `struct`:

```csharp
pulbic record struct MyRecordStruct(int Id, string Name);
```

Mientras que una clase `record` podríamos decidir marcarla o no:

```csharp
pulbic record class MyRecordClass1(int Id, string Name);
pulbic record MyRecordClass2(int Id, string Name);
```

Este tipo de objetos está destinado principalmente a ser inmutables, añadir descomposición y tener una forma de declaración concisa. Actualmente son tipos de referencia, un puntero a memoria. Resulta totalmente lógico querer dotar a los tipos valor (que se almacenan en el *stack*) de estas ventajas.

No obstante, aun no he llegado a encontrar ese escenario en el que usar este tipo de objetos me supondría una ventaja grande. Y esto unido con una declaración de este tipo:

```csharp
public abstract record class MyClass(int Id);
```

Hacen que no pueda ser tan bondadoso con esta característica como lo fui con su antecesora.

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>5</b></p>
> <p>Crazy  = <b>5</b></p>

## Static abstract members in interfaces

Cuando hablamos de una nueva versión de C#, el tema de dar más funcionalidad a una `interface` de la que ya tiene, sigue en el candelero.

Esta vez le toca a poder declarar métodos estáticos:

```csharp
interface IAddable<T> where T : IAddable<T>
{
  static abstract T Zero { get; }
  static abstract T operator +(T t1, T t2);
}
struct Int32 : ..., IAddable<Int32>
{
  static Int32 I.operator +(Int32 x, Int32 y) => x + y; 
  public static int Zero => 0;
}
```

Como podemos ver en el ejemplo anterior, la idea sería poder obligar a implementar operadores o incluso tener un operador ya implementado por defecto en nuestra `interface`.

De hecho, esta funcionalidad podría servir para declarar interfaces para métodos estáticos de todo tipo:

```csharp
public interface IAsyncFactory<T>
{
  abstract static Task<T> CreateAsync();
}
```

Pero a parte de su uso para operadores, imaginemos este código:

```csharp
public interface IExample
{
  string DefaultInstanceProperty => "default instance property";
  static string DefaultStaticProperty => "default static property";
}
```

Aquí hemos declararíamos dos propiedades con comportamiento por defecto: una que usaríamos en forma de instancia y la otra de forma estática.

Si queremos usar y sacar partido de esta funcionalidad podría crear la siguiente clase:

```csharp
class MyGenericClass<T> where T : class, IExample
{
  public MyGenericClass(TVar var)
  {
    var a = var.DefaultInstanceProperty;
    var b = T.DefaultStaticProperty; // ???
    var c = IExample.DefaultStaticProperty;
  }
}
```

La asignación de la variable `b` ¿sería correcta?. Es una pregunta al aire porque las personas involucradas en la mejora de C# no ha encontrado una respuesta todavía.

Una característica que podría ser muy interesante, pero que, como siempre que damos una mayor funcionalidad a una interfaz, podríamos solucionar con multiherencia y/o usando clases.

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>7</b></p>
> <p>Crazy  = <b>9</b></p>

## File scoped namespaces

```csharp
using System;

namespace Company.Project
{
  public class Product
  {
    ...
  }
}
```

```csharp
namespace Company.Project
using System;

public class Product
{
    ...
}
```

```csharp
using System;
namespace Company;
namespace Project;
public class Product { }
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>7</b></p>
> <p>Crazy  = <b>1</b></p>

## Lambda improvements

```csharp
app.MapAction([HttpGet("/")] () => new Todo(Id: 0, Name: "Name"));
app.MapAction([HttpPost("/")] ([FromBody] Todo todo) => todo);
```

### Allow lambdas with attributes

### Allow lambdas with explicit return type

```csharp
var f4 = () => 1;              // System.Func<int>
var f5 = () : string => null;  // System.Func<string>
```

### Infer a natural delegate type for lambdas and method groups

```csharp
Delegate d1 = 1.GetHashCode;
object o1 = (int x) => x;
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>10</b></p>
> <p>Crazy  = <b>10</b></p>

## Allow Generic Attributes

```csharp
public class GenericClass<T>
{
  [SomeAttribute<T>]
  public void DoSomething(T input)
  {
  }
}

public class SomeAttribute<T> : Attribute
{
}
```

```csharp
[ProducesResponseType<TEntity>(200)]
[ProducesResponseType(400)]
public virtual Task<IActionResult> GetById(int id)
{
```

`IActionResult<T>`

is that attribute arguments of type System.Type are stored as serialized strings containing the assembly-qualified name. What string can be deserialized (similar to Type.GetType) in such a way that it resolves to a generic type parameter?

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>8</b></p>
> <p>Crazy  = <b>7</b></p>

## Deconstruction improvements

### Mix Declarations and Variables

```csharp
Err err;
Ret1 ret1;
(ret1, err) = await Func1();
if (err) return (default, err);

Ret2 ret2;
(ret2, err) = await Func1();
if (err) return (default, err);
```

```csharp
Err err;
(var ret1, err) = await Func1();
if (err) return (default, err);

(var ret2, err) = await Func1();
if (err) return (default, err);
```

### Defaul deconstruction

```csharp
(int i, string j) = default;
```

`(default, default)`

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>6</b></p>
> <p>Crazy  = <b>3</b></p>

## List patterns

```csharp
collection switch
{
   { 1, 2, 3, .., 5 } => ... // causes start buffer to hold 3 elements
   {1,  .., 3, 4, 5 } => ... // causes end buffer to hold 3 elements
}
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>4</b></p>
> <p>Crazy  = <b>8</b></p>

## Property-Scoped Fields

```csharp
public string MyProperty
{
  get { return field; }
  set
  {
    field = value;
    NotifyOfPropertyChange(nameof(MyProperty));
  }
}
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>6</b></p>
> <p>Crazy  = <b>7</b></p>

## Required Properties

```csharp
public string Foo { get; required set; }
public string Bar { get; required init; }
```

> <p><b>Valoración</b>:</p>
> <p>Useful = <b>5</b></p>
> <p>Crazy  = <b>8</b></p>

## Conclusiones

![resultados escala sexy-loca](/assets/uploads/2021/05/csharp-10.png)

https://github.com/dotnet/roslyn/blob/main/docs/Language%20Feature%20Status.md

https://github.com/dotnet/csharplang/milestone/19