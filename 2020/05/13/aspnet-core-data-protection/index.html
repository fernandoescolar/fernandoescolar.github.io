<!DOCTYPE html>
<html lang="es-es">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
		<title>
			Asp.Net core data protection · developerro
		</title>
		<!-- Social Metas -->
		<meta name="description" content="Cuando encontr&#233; en stackoverflow mi primer algoritmo para encriptar datos, fue como entrar por primera vez en Hogwarts, la escuela de magia y hechicer&#237;a. No ..." />
		<meta property="og:title" content="Asp.Net core data protection" />
		<meta property="og:type" content="article" />
		<meta property="og:url" content="https://www.developerro.com/2020/05/13/aspnet-core-data-protection" />
		<meta property="og:image" content="https://www.developerro.com/assets/uploads/2020/05/hogwarts.jpg" />
		<meta property="og:description" content="Cuando encontré en stackoverflow mi primer algoritmo para encriptar datos, fue como entrar por primera vez en Hogwarts, la escuela de magia y hechicería. No ..." />
		<meta property="og:site_name" content="developerro" />
		<meta property="og:locale" content="es_es" />
		<meta property="article:modified_time" content="2020-05-13 07:00:41Z" />
		<meta property="article:published_time" content="2020-05-13 07:00:41Z" />
		<meta property="article:author" content="Fernando Escolar" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/24/azure-functions-net-5" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/10/efcore-vs-records" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/03/chorra-tip-1-wcd-command" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@fernandoescolar" />
		<meta name="twitter:creator" content="@fernandoescolar" />
		<meta name="twitter:title" content="Asp.Net core data protection" />
		<meta name="twitter:description" content="Cuando encontré en stackoverflow mi primer algoritmo para encriptar datos, fue como entrar por primera vez en Hogwarts, la escuela de magia y hechicería. No ..." />
		<meta name="twitter:image" content="https://www.developerro.com/assets/uploads/2020/05/hogwarts.jpg" />
		<meta name="twitter:url" content="https://www.developerro.com/2020/05/13/aspnet-core-data-protection" />
		<meta name="description" content="Cuando encontré en stackoverflow mi primer algoritmo para encriptar datos, fue como entrar por primera vez en Hogwarts, la escuela de magia y hechicería. No ..." />
		<link rel="alternate" type="application/atom+xml" title="Developerro" href="/atom.xml" />
		<link rel="canonical" href="https://www.developerro.com/2020/05/13/aspnet-core-data-protection" />
		<!-- Icons -->
		<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-144-precomposed.png" />
		<link rel="shortcut icon" href="/assets/favicon.ico" />
		<!-- RSS -->
		<link rel="alternate" type="application/rss+xml" title="Developerro" href="/atom.xml" />
		<!-- Styles -->
		<link href="https://fonts.googleapis.com/css?family=Lato:400,700" rel="stylesheet" type="text/css" />
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" type="text/css" />
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" type="text/css" />
		<link rel="stylesheet" href="/assets/vendor/fontawesome-free/css/all.min.css" />
		<link rel="stylesheet" href="/assets/main.css" />
		<link rel="stylesheet" href="/assets/syntax.css" />
		<!-- Analytics -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=UA-163390000-1">
		</script>
		<script>
			
			    function activateGoogleAnalytics() {
			        window.dataLayer = window.dataLayer || [];
			        function gtag(){dataLayer.push(arguments);}
			        gtag('js', new Date());
			        gtag('config', 'UA-163390000-1');
			    }
			
		</script>
		<style>
			
			    header { background: linear-gradient(to bottom, rgba(228, 225, 216, 0.95) 0%, rgba(172, 65, 66, 0.55) 100%), url(/assets/uploads/2020/05/hogwarts.jpg) center / cover; }
			  
		</style>
	</head>
	<body>
		<nav>
			<i id="hamburger">
			</i> <a href="/">
				<b>
					d</b>eveloperro
			</a>
			<ul>
				<li>
					<a href="/posts">blog
					</a>
				</li>
				<li>
					<a href="/about">
						acerca de
					</a>
				</li>
				<li>
					<a href="/archive">
						archivo
					</a>
				</li>
				<li>
					<a href="/projects">
						oss
					</a>
				</li>
				<li>
					<a href="/search">
						buscar
					</a>
				</li>
				<li>
					<a href="/videos">
						vídeos
					</a>
				</li>
			</ul>
		</nav>
		<header class="post">
			<h1>
				Asp.Net core data protection
			</h1><small>13 may. 2020 · 9 min. de lectura
			</small>
		</header>
		<article class="post">
			<p>
				Cuando encontré en <a href="https://stackoverflow.com/search?q=c%23+encrypt+data">stackoverflow
				</a> mi primer algoritmo para encriptar datos, fue como entrar por primera vez en Hogwarts, la escuela de magia y hechicería. No entendía muy bien que era eso, pero podía copiar el código y hacer lo mismo en mis aplicaciones
				<!--break-->
				.
			</p>
			<p>
				<img src="/assets/uploads/2020/05/hogwarts.jpg" alt="Hogwarts" />
			</p>
			<p>
				La criptografía, a pesar de ser una ciencia que resulta muy divertida, es también muy complicada. Cada algoritmo, las claves públicas, las privadas, los saltos, base64, los certificados y sus movidas.
			</p>
			<p>
				Menos mal que Microsoft ha sacado una librería para hacer toda esta mierda sin tener que copiar código y entiendo más o menos lo mismo acerca de qué es lo que pasa por dentro.
			</p>
			<h2 id="quick-start">
				Quick start
			</h2>
			<p>
				Cuentan las leyendas que existe un paquete de <em>nuget
				</em> llamado <code>Microsoft.AspNetCore.DataProtection
				</code> que puedes instalar en tus aplicaciones.
			</p>
			<p>
				Ese paquete contiene el conjuro necesario para evitar que los mortífagos se hagan con el libro de hechizos de Dumbledore. Esto es importante, si no, la batalla del bien contra el mal se decantaría del lado de <em>El-Que-No-Debe-Ser-Nombrado
				</em>.
			</p>
			<p>
				Para usar este conjuro solo necesitamos sacar nuestras varitas:
			</p>
			<pre class="language-csharp highlight">
<code>public void ConfigureServices(IServiceCollection services)
{
  // ...
  services.AddDataProtection();
}
				</code>
</pre>
			<p>
				Realizar un leve gesto de izquierda a derecha:
			</p>
			<pre class="language-csharp highlight">
<code>public class SecureUserRepository
{
  private readonly IDataProtector _protector;

  public SecureUserRepository(IDataProtectionProvider protectionProvider)
  {
    _protector = protectionProvider.CreateProtector(nameof(SecureUserRepository));
  }
}
				</code>
</pre>
			<p>
				Y recitar los hechizos de <code>Protect
				</code>o <code>Unprotect
				</code> según la necesidad:
			</p>
			<pre class="language-csharp highlight">
<code>public IEnumerable
					<userlistitem>
						LoadUsers()
{
  var users = ...;
  foreach(var user in users)
  {
      user.Id = _protector.Protect(user.Id);
      user.Email = _protector.Protect(user.Email);
      user.Phone = _protector.Protect(user.Phone);

      yield return user;
  }
}

public UserDetails LoadUser(string encryptedId)
{
    var id = _protector.Unprotect(encryptedId);
    var user = ...;

    return user;
}</userlistitem>
				</code>
</pre>
			<blockquote>
				<p>
					Wingardium Leviosa
				</p>
			</blockquote>
			<p>
				<img src="/assets/uploads/2020/05/wingardium-leviosa.gif" alt="Wingardium Leviosa" />
			</p>
			<h2 id="more-in-depth">
				More in depth
			</h2>
			<p>
				El secreto de su eficacia se basa en la función <code>CreateProtector(string)
				</code>. Según el nombre que especifiquemos, podremos llegar a desproteger un dato o no.
			</p>
			<p>
				Vamos a preparar unas pociones para sacar lo mejor de estos hechizos:
			</p>
			<pre class="language-csharp highlight">
<code>private readonly IDataProtectionProvider _provider;

public DataProtectionTests()
{
  var services = new ServiceCollection();
  services.AddDataProtection();
  var serviceProvider = services.BuildServiceProvider();
  _provider = _serviceProvider.GetService
					<idataprotectionprovider>
						();
}</idataprotectionprovider>
				</code>
</pre>
			<p>
				Como ya hemos visto, podríamos proteger y desproteger una cadena de texto:
			</p>
			<pre class="language-csharp highlight">
<code>[Fact]
public void ProtectsString()
{
  const string expected = "this is a random string";

  var protector = _provider.CreateProtector(nameof(ProtectsString));
  var unreadable = protector.Protect(expected);

  var unprotector = _provider.CreateProtector(nameof(ProtectsString));
  var readable = unprotector.Unprotect(unreadable);

  Assert.NotEqual(expected, unreadable);
  Assert.Equal(expected, readable);
}
				</code>
</pre>
			<p>
				Y también podemos proteger <code>arrays
				</code> de <code>bytes
				</code>:
			</p>
			<pre class="language-csharp highlight">
<code>[Fact]
public void ProtectsByte()
{
  const string expected = "this is a random string";

  var byteArray = Encoding.UTF8.GetBytes(expected);
  var protector = _provider.CreateProtector(nameof(ProtectsByte));
  var protectedBytes = protector.Protect(byteArray);

  var unprotector = _provider.CreateProtector(nameof(ProtectsByte));
  var unprotectedBytes = protector.Unprotect(protectedBytes);
  var actual = Encoding.UTF8.GetString(unprotectedBytes);

  Assert.NotEqual(protectedBytes, unprotectedBytes);
  Assert.Equal(expected, actual);
}
				</code>
</pre>
			<p>
				Pero si cambiamos el nombre, entonces nos encontraremos con una excepción:
			</p>
			<pre class="language-csharp highlight">
<code>[Fact]
public void CanNotUnprotectWithDiferentProtectors()
{
  const string expected = "this is a random string";

  var protector = _provider.CreateProtector(nameof(CanNotUnprotectWithDiferentProtectors));
  var unreadable = protector.Protect(expected);

  var unprotector = _provider.CreateProtector(nameof(ProtectsString));

  Assert.Throws
					<cryptographicexception>
						(() => unprotector.Unprotect(unreadable));
}</cryptographicexception>
				</code>
</pre>
			<blockquote>
				<p>
					Expecto Patronum
				</p>
			</blockquote>
			<p>
				<img src="/assets/uploads/2020/05/expecto-patronum.gif" alt="Expecto Patronum" />
			</p>
			<h2 id="time-limited">
				Time limited
			</h2>
			<p>
				Si añadimos el paquete de <em>nuget
				</em> llamado <code>Microsoft.AspNetCore.DataProtection.Extensions
				</code> añadimos una funcionalidad muy interesante: crear datos encriptados con fecha de caducidad, a partir de la cual, ya no se pueden desencriptar.
			</p>
			<p>
				Para ello necesitamos añadir al leve gesto de varita de izquierda a derecha, otro movimiento de arriba a abajo:
			</p>
			<pre class="language-csharp highlight">
<code>public class SecureTokenProvider
{
  private readonly ITimeLimitedDataProtector _protector;

  public SecureUserRepository(IDataProtectionProvider protectionProvider)
  {
    var parentProtector = protectionProvider.CreateProtector(nameof(SecureTokenProvider));

    _protector = parentProtector.ToTimeLimitedDataProtector();
  }
}
				</code>
</pre>
			<p>
				Y cuando recitemos el hechizo <code>Protect
				</code> podremos añadir el tiempo que pasará hasta que ya no podamos realizar el <code>Unprotect
				</code>:
			</p>
			<pre class="language-csharp highlight">
<code>public string CreateToken()
{
  var text = ...;
  var token = _protector.Protect(text, TimeSpan.FromDays(7));

  return token;
}
				</code>
</pre>
			<p>
				Y podríamos probar con otra pócima, cómo al caducar la información, nos da una excepción:
			</p>
			<pre class="language-csharp highlight">
<code>[Fact]
public void CanNotUnprotectExpiredInformation()
{
  const string expected = "this is a random string";

  var protector = _provider.CreateProtector(nameof(CanNotUnprotectExpiredInformation));
  var timeLimitedProtector = protector.ToTimeLimitedDataProtector();
  var unreadable = timeLimitedProtector.Protect(expected, TimeSpan.FromSeconds(1));

  Thread.Sleep(1001);

  var unprotector = _provider.CreateProtector(nameof(CanNotUnprotectExpiredInformation));
  var timeLimitedUnprotector = unprotector.ToTimeLimitedDataProtector();

  Assert.Throws
					<cryptographicexception>
						(() => timeLimitedUnprotector.Unprotect(unreadable));
}</cryptographicexception>
				</code>
</pre>
			<blockquote>
				<p>
					Expelliarmus
				</p>
			</blockquote>
			<p>
				<img src="/assets/uploads/2020/05/expelliarmus.gif" alt="Expelliarmus" />
			</p>
			<h2 id="key-ring">
				Key ring
			</h2>
			<p>
				A la hora de la verdad toda esta movida es muy segura. Para proteger el libro de hechizos de Dumbledore, no solo estamos usando un movimiento de varita específico (<em>name
				</em>) en el método <code>CreateProtector
				</code>. Además, esta librería usa internamente un juego de varitas (<em>keys
				</em> de cifrado). Cada varita está habilitada para diferentes ocasiones y se gestionan internamente en un almacén al que llamamos <em>key ring
				</em>. Una suerte de tienda de Ollivander, donde ir almacenando las varitas antiguas y las nuevas, en local o de forma distribuida y de una forma segura.
			</p>
			<p>
				Este <em>key ring
				</em> nos proporciona un lugar donde a pesar de que pase el tiempo, podremos ir a buscar las claves criptográficas. Nos protegerá en caso de que se generen nuevas. Y hará que todo el sistema se comporte perfectamente, incluso cuando usemos diferentes instancias o aplicaciones.
			</p>
			<p>
				Para ello se nos permitirá definir:
			</p>
			<h3 id="aplicacion">
				Aplicación
			</h3>
			<p>
				Por defecto, el sistema buscará el nombre de la aplicación según las dll's y el contenido que estamos ejecutando. Pero para estar seguros de que usamos el mismo <em>key ring
				</em> (incluso entre diferentes aplicaciones), lo mejor es poner un nombre en la configuración para nuestra aplicación:
			</p>
			<pre class="language-csharp highlight">
<code>services.AddDataProtection()
        .SetApplicationName("shared app name");
				</code>
</pre>
			<h3 id="persistencia">
				Persistencia
			</h3>
			<p>
				Podemos especificar un lugar donde almacenar las claves criptográficas. Podríamos llegar a usar una unidad local o compartida:
			</p>
			<pre class="language-csharp highlight">
<code>services.AddDataProtection()
        .PersistKeysToFileSystem(new DirectoryInfo(@"\\shared\protection\"));
				</code>
</pre>
			<p>
				O instalando diferentes paquetes adicionales, como por ejemplo <code>Microsoft.AspNetCore.DataProtection.AzureStorage
				</code>, almacenarlas en un <strong>Azure Storage
				</strong>, en <strong>AWS
				</strong>, <strong>Redis
				</strong>, ...:
			</p>
			<pre class="language-csharp highlight">
<code>services.AddDataProtection()
        .PersistKeysToAzureBlobStorage(new Uri("
					<bloburiwithsastoken>
						"));</bloburiwithsastoken>
				</code>
</pre>
			<h3 id="proteccion">
				Protección
			</h3>
			<p>
				Otro detalle que tenemos que tener en cuenta es la protección de las claves de cifrado. La librería nos provee de una serie de facilidades con las que podremos añadir una protección de estas claves por certificado:
			</p>
			<pre class="language-csharp highlight">
<code>services.AddDataProtection()
        .PersistKeysToFileSystem(new DirectoryInfo(@"\\shared\protection\"))
        .ProtectKeysWithCertificate("thumbprint");
				</code>
</pre>
			<p>
				O, por ejemplo, usando un <strong>Azure Key Vault
				</strong>:
			</p>
			<pre class="language-csharp highlight">
<code>services.AddDataProtection()
        .PersistKeysToAzureBlobStorage(new Uri("
					<bloburiwithsastoken>
						"))
        .ProtectKeysWithAzureKeyVault("
						<keyidentifier>
							", "
							<clientid>
								", "
								<clientsecret>
									");;
								</clientsecret>
							</clientid>
						</keyidentifier></bloburiwithsastoken>
				</code>
</pre>
			<h3 id="rotacion-de-claves">
				Rotación de claves
			</h3>
			<p>
				Si no especificamos lo contrario, se irán generando nuevas claves en el <em>key ring
				</em> cada 90 días. Pero puede ser que esta periodicidad no nos venga bien. Pero podremos especificar cada cuantos días queremos rotarlas:
			</p>
			<pre class="language-csharp highlight">
<code>services.AddDataProtection()
        .SetDefaultKeyLifetime(TimeSpan.FromDays(14));
				</code>
</pre>
			<h3 id="no-generar-claves-automaticamente">
				No generar claves automáticamente
			</h3>
			<p>
				Por último, se podría dar el caso de que no queramos que una aplicación o una instancia esclava de nuestro sistema creara claves, para ello podríamos usar la siguiente configuración:
			</p>
			<pre class="language-csharp highlight">
<code>services.AddDataProtection()
        .DisableAutomaticKeyGeneration();
				</code>
</pre>
			<p>
				Básicamente, nos encontraremos con un poder absoluto sobre el comportamiento de este <strong>key ring
				</strong>. Aunque personalmente, lo que recomendaría por mi experiencia sería usar:
			</p>
			<ul>
				<li>
					<p>
						Nombre de aplicación
					</p>
				</li>
				<li>
					<p>
						Azure Storage como almacenamiento
					</p>
				</li>
				<li>
					<p>
						Azure Key Vault como protección
					</p>
				</li>
			</ul>
			<p>
				Con estas 3 configuraciones, tendríamos un sistema de protección escalable, seguro y distribuido.
			</p>
			<blockquote>
				<p>
					Avada Kedavra
				</p>
			</blockquote>
			<p>
				<img src="/assets/uploads/2020/05/avada-kedavra.gif" alt="Avada Kedavra" />
			</p>
			<h2 id="otras-configuraciones">
				Otras configuraciones
			</h2>
			<p>
				Otras posibilidades de <strong>Asp.Net Data Protection
				</strong> es la personalización de el algoritmo a usar para encriptar la información:
			</p>
			<pre class="language-csharp highlight">
<code>services.AddDataProtection()
        .UseCryptographicAlgorithms(
        new AuthenticatedEncryptorConfiguration()
        {
            EncryptionAlgorithm = EncryptionAlgorithm.AES_256_CBC,
            ValidationAlgorithm = ValidationAlgorithm.HMACSHA256
        });
				</code>
</pre>
			<p>
				Pero si esta configuración nos parece insuficiente, siempre podemos implementar un algoritmo propio:
			</p>
			<pre class="language-csharp highlight">
<code>services.AddDataProtection()
        .UseCustomCryptographicAlgorithms(...);
				</code>
</pre>
			<blockquote>
				<p>
					Alohomora
				</p>
			</blockquote>
			<p>
				<img src="/assets/uploads/2020/05/alohomora.gif" alt="Alohomora" />
			</p>
			<h2 id="conclusiones">
				Conclusiones
			</h2>
			<p>
				Es genial tener este libro de magia. Nos aporta un nuevo punto de vista de la protección de la información dentro de nuestras aplicaciones en Asp.Net Core. Un estándar. Además, tienen otras aplicaciones, como podría ser la generación de tokens de validación y otras cosas relacionadas con la seguridad.
			</p>
			<p>
				En mis proyectos lo estamos usando ya, así que...
			</p>
			<blockquote>
				<p>
					Obliviate
				</p>
			</blockquote>
			<p>
				<img src="/assets/uploads/2020/05/obliviate.gif" alt="Obliviate" />
			</p>
		</article>
		<section id="share">
			<a href="https://twitter.com/intent/tweet?text=Asp.Net core data protection&url=https://www.developerro.com/2020/05/13/aspnet-core-data-protection" rel="nofollow" target="_blank" title="Share on Twitter">
				<i class="fab fa-twitter">
				</i>
			</a> <a href="https://facebook.com/sharer.php?u=https://www.developerro.com/2020/05/13/aspnet-core-data-protection" rel="nofollow" target="_blank" title="Share on Facebook">
				<i class="fab fa-facebook"></i>
			</a> <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.developerro.com/2020/05/13/aspnet-core-data-protection" rel="nofollow" target="_blank" title="Share on Linkedlin">
				<i class="fab fa-linkedin"></i>
			</a> <a href="http://www.reddit.com/submit?url=https://www.developerro.com/2020/05/13/aspnet-core-data-protection" rel="nofollow" target="_blank" title="Share on Reddit">
				<i class="fab fa-reddit"></i>
			</a> <a href="https://www.buymeacoffee.com/fernandoescolar" rel="nofollow" target="_blank" title="Buy me a beer">
				<i class="fa fa-beer"></i> buy me a beer
			</a>
		</section>
		<section id="related">
			<h2>
				Relacionado (o no)
			</h2>
			<ul>
				<li>
					<a href="/2021/03/24/azure-functions-net-5">
						Azure Functions con .NET 5
					</a> <small>24 mar. 2021
					</small>
				</li>
				<li>
					<a href="/2021/03/10/efcore-vs-records">
						EF Core vs. Records
					</a> <small>10 mar. 2021
					</small>
				</li>
				<li>
					<a href="/video/2021/02/27/raiders-od-the-lost-leak">
						Raiders of the lost leak
					</a> <small>27 feb. 2021
					</small>
				</li>
				<li>
					<a href="/video/2020/12/09/net-5-just-talking">
						.Net 5 Just Talking
					</a> <small>09 dic. 2020
					</small>
				</li>
				<li>
					<a href="/2020/08/19/csharp-9">
						Novedades de c# 9
					</a> <small>19 ago. 2020
					</small>
				</li>
			</ul>
		</section>
		<footer>
			<ul>
				<li>
					<a href="mailto:fer.escolar@gmail.com" target="_blank">
						<i class="far fa-envelope">
						</i>
					</a>
				</li>
				<li>
					<a href="https://twitter.com/fernandoescolar" target="_blank">
						<i class="fab fa-twitter">
						</i>
					</a>
				</li>
				<li>
					<a href="https://www.linkedin.com/in/fernandoescolar" target="_blank">
						<i class="fab fa-linkedin">
						</i>
					</a>
				</li>
				<li>
					<a href="https://github.com/fernandoescolar" target="_blank">
						<i class="fab fa-github">
						</i>
					</a>
				</li>
				<li>
					<a href="https://www.buymeacoffee.com/fernandoescolar" target="_blank">
						<i class="fa fa-beer">
						</i>
					</a>
				</li>
			</ul><a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">
				<img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
			</a>
		</footer>
		<dialog id="cookie-notice">
			Nos gustaría usar cookies de terceros para hacer este sitio mejor. <a id="cookie-notice-accept">vale
			</a>
		</dialog>
		<script src="/assets/scripts.js">
		</script>
	</body>
</html>