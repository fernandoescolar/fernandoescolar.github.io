<!DOCTYPE html>
<html lang="es-es">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
		<title>
			Azure Functions: custom out bindings · developerro
		</title>
		<!-- Social Metas -->
		<meta name="description" content="La gran ventaja en de Azure Functions frente a otra tecnolog&#237;a es que escribes muy poco c&#243;digo, ya que solo debes gestionar como fluyen los datos usando unos..." />
		<meta property="og:title" content="Azure Functions: custom out bindings" />
		<meta property="og:type" content="article" />
		<meta property="og:url" content="https://www.developerro.com/2019/04/15/azure-functions-custom-out-bindings" />
		<meta property="og:image" content="https://www.developerro.com/assets/uploads/bg/thunder2.jpg" />
		<meta property="og:description" content="La gran ventaja en de Azure Functions frente a otra tecnología es que escribes muy poco código, ya que solo debes gestionar como fluyen los datos usando unos..." />
		<meta property="og:site_name" content="developerro" />
		<meta property="og:locale" content="es_es" />
		<meta property="article:modified_time" content="2019-04-15 07:59:45Z" />
		<meta property="article:published_time" content="2019-04-15 07:59:45Z" />
		<meta property="article:author" content="Fernando Escolar" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/24/azure-functions-net-5" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/10/efcore-vs-records" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/03/chorra-tip-1-wcd-command" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@fernandoescolar" />
		<meta name="twitter:creator" content="@fernandoescolar" />
		<meta name="twitter:title" content="Azure Functions: custom out bindings" />
		<meta name="twitter:description" content="La gran ventaja en de Azure Functions frente a otra tecnología es que escribes muy poco código, ya que solo debes gestionar como fluyen los datos usando unos..." />
		<meta name="twitter:image" content="https://www.developerro.com/assets/uploads/bg/thunder2.jpg" />
		<meta name="twitter:url" content="https://www.developerro.com/2019/04/15/azure-functions-custom-out-bindings" />
		<meta name="description" content="La gran ventaja en de Azure Functions frente a otra tecnología es que escribes muy poco código, ya que solo debes gestionar como fluyen los datos usando unos..." />
		<link rel="alternate" type="application/atom+xml" title="Developerro" href="/atom.xml" />
		<link rel="canonical" href="https://www.developerro.com/2019/04/15/azure-functions-custom-out-bindings" />
		<!-- Icons -->
		<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-144-precomposed.png" />
		<link rel="shortcut icon" href="/assets/favicon.ico" />
		<!-- RSS -->
		<link rel="alternate" type="application/rss+xml" title="Developerro" href="/atom.xml" />
		<!-- Styles -->
		<link href="https://fonts.googleapis.com/css?family=Lato:400,700" rel="stylesheet" type="text/css" />
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" type="text/css" />
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" type="text/css" />
		<link rel="stylesheet" href="/assets/vendor/fontawesome-free/css/all.min.css" />
		<link rel="stylesheet" href="/assets/main.css" />
		<link rel="stylesheet" href="/assets/syntax.css" />
		<!-- Analytics -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=UA-163390000-1">
		</script>
		<script>
			
			    function activateGoogleAnalytics() {
			        window.dataLayer = window.dataLayer || [];
			        function gtag(){dataLayer.push(arguments);}
			        gtag('js', new Date());
			        gtag('config', 'UA-163390000-1');
			    }
			
		</script>
		<style>
			
			    header { background: linear-gradient(to bottom, rgba(228, 225, 216, 0.95) 0%, rgba(172, 65, 66, 0.55) 100%), url(/assets/uploads/bg/thunder2.jpg) center / cover; }
			  
		</style>
	</head>
	<body>
		<nav>
			<i id="hamburger">
			</i> <a href="/">
				<b>
					d</b>eveloperro
			</a>
			<ul>
				<li>
					<a href="/posts">blog
					</a>
				</li>
				<li>
					<a href="/about">
						acerca de
					</a>
				</li>
				<li>
					<a href="/archive">
						archivo
					</a>
				</li>
				<li>
					<a href="/projects">
						oss
					</a>
				</li>
				<li>
					<a href="/search">
						buscar
					</a>
				</li>
				<li>
					<a href="/videos">
						vídeos
					</a>
				</li>
			</ul>
		</nav>
		<header class="post">
			<h1>
				Azure Functions: custom out bindings
			</h1><small>15 abr. 2019 · 10 min. de lectura
			</small>
		</header>
		<article class="post">
			<p>
				La gran ventaja en de Azure Functions frente a otra tecnología es que escribes muy poco código, ya que solo debes gestionar como fluyen los datos usando unos <em>bindings
				</em> de entrada y salida. El propio SDK nos aporta un buen conjunto por defecto de <em>bindings
				</em> que nos ayudarán a tratar con peticiones HTTP, Azure Storage Account (Blob, Queue y Table), Service Bus o Cosmos DB. Pero ¿y si quiero integrarme con otro sistema no soportado?
				<!--break-->
			</p>
			<p>
				Afortunadamente en la v2 de Azure Functions, basadas en dotnet core, podemos encontrar un sistema de extensión en el que podremos crearnos todo tipo de <em>bindings
				</em> y <em>triggers
				</em> personalizados.
			</p>
			<p>
				En este artículo vamos a crear un <em>out binding
				</em> que nos ayudará a realizar un simple envío de emails basándonos en una conexión SMTP.
			</p>
			<p>
				Generalmente, cuando queramos enviar un email usando el protocolo SMTP desde dotnet core, usaremos un código muy semejante a este:
			</p>
			<pre class="language-csharp highlight">
<code>var smtp = new SmtpClient(host, port);
smtp.EnableSsl = useSsl;
smtp.Credentials = new NetworkCredential(user, password);

var fromAddress = new MailAddress(from);
var toAddress = new MailAddress(to);
var message = new MMessage(fromAddress, toAddress);
message.Subject = subject;
message.Body = body;

await smtp.SendMailAsync(message);
				</code>
</pre>
			<p>
				Lo que vamos a hacer es crear un nuevo proyecto con un <em>binding
				</em> que nos facilitará esta tarea. Para ello, crearemos una nueva solución de tipo librería de .net standard 2.0 y añadiremos una referencia al paquete de NuGet <code>Microsoft.Azure.WebJobs.Extensions
				</code>, que es donde encontramos todo lo necesario para crear nuestra extensión.
			</p>
			<p>
				Después definiremos nuestro atributo de <em>binding
				</em>. Ese que podemos ver en los parámetros de la <em>Azure Function
				</em> entre corchetes. Así que buscaremos un nombre que defina correctamente lo que queremos hacer y le añadiremos "Attribute":
			</p>
			<pre class="language-csharp highlight">
<code>[AttributeUsage(AttributeTargets.ReturnValue | AttributeTargets.Parameter)]
[Binding]
public class MailSendAttribute : Attribute
{
    public string Host { get; set; }

    public int Port { get; set; }

    public string User { get; set; }

    public string Password { get; set; }

    public bool UseSsl { get; set; }
}
				</code>
</pre>
			<p>
				Le hemos añadido ciertas características para delimitar el uso de este atributo solo como valor devuelto por una función o como parámetro de esta. Y hemos añadido una serie de propiedades que nos ayudan a definir una conexión SMTP.
			</p>
			<p>
				Pero quizá encontremos demasiado tedioso ir definiendo propiedad por propiedad y nos puede resultar más sencillo usar un <code>AppSetting
				</code> que contenga una especie de cadena de conexión a nuestro servidor. Para ello vamos a añadir una propiedad llamada <code>Connection
				</code> y la vamos a decorar con el atributo <code>AppSetting
				</code> para que el sistema interprete que este valor lo debe leer de las variables de entorno o del archivo <code>local.settings.json
				</code>:
			</p>
			<pre class="language-csharp highlight">
<code>[AppSetting]
public string Connection { get; set; }
				</code>
</pre>
			<p>
				Y para rellenar todas las propiedades de <code>MailSendAttribute
				</code>, vamos a añadir una función que nos ayude a transformar esa cadena de conexión:
			</p>
			<pre class="language-csharp highlight">
<code>internal void Autofill()
{
    if (string.IsNullOrEmpty(Connection)) return;

    var values = Connection.Split(';').ToDictionary(x => x.Split('=')[0].Trim().ToLowerInvariant(), x => x.Split('=')[1].Trim());

    if (values.ContainsKey("host"))
    {
        Host = values["host"];
    }

    if (values.ContainsKey("port") && int.TryParse(values["port"], out int port))
    {
        Port = port;
    }

    if (values.ContainsKey("user"))
    {
        User = values["user"];
    }

    if (values.ContainsKey("password"))
    {
        Password = values["password"];
    }

    if (values.ContainsKey("usessl") && bool.TryParse(values["usessl"], out bool useSsl))
    {
        UseSsl = useSsl;
    }

    if (string.IsNullOrEmpty(Host) || Port <= 0)
    {
        throw new ArgumentException("You should specify 'Host' and 'Port' SMTP connection parameters.");
    }
}
				</code>
</pre>
			<p>
				Para definir una cadena de conexión válida para tiempo de desarrollo, iremos al archivo <code>local.settings.json
				</code> y en la propiedad <code>Values
				</code> añadiremos:
			</p>
			<pre class="language-json highlight">
<code>"Values": {
    "SmtpConnectionString": "Host=smtp.server.com;Port=587;User=myUser;Password=myPassword;UseSsl=true"
  }
				</code>
</pre>
			<p>
				Ya tenemos definido nuestro atributo de <em>binding
				</em>, ahora definiremos el tipo de objeto que vamos a manejar. En este caso será un email, para lo que crearemos un nuevo objeto serializable a JSON con los datos necesarios:
			</p>
			<pre class="language-csharp highlight">
<code>public class MailMessage
{
    [JsonProperty("from")]
    public string From { get; set; }

    [JsonProperty("to")]
    public string To { get; set; }

    [JsonProperty("subject")]
    public string Subject { get; set; }

    [JsonProperty("body")]
    public string Body { get; set; }
}
				</code>
</pre>
			<p>
				Ya tenemos un atributo y el objeto que va a utilizar nuestro <em>binding
				</em>, ahora tendremos que definir el recolector, el manejador o como queramos llamar al artefacto que va a gestionar la dirección <em>out
				</em> del <em>binding
				</em>. Esta clase debe implementar la interfaz genérica <code>IAsyncCollector&lt;T>
				</code>, donde <code>T
				</code> es el objeto manejado. Para este caso <code>MailMessage
				</code>:
			</p>
			<pre class="language-csharp highlight">
<code>public class MailAsyncCollector : IAsyncCollector
					<mailmessage>
						{
    public Task AddAsync(MailMessage item, CancellationToken cancellationToken = default)
    {
    }

    public Task FlushAsync(CancellationToken cancellationToken = default)
    {
    }
}</mailmessage>
				</code>
</pre>
			<p>
				Por cuestiones de simplicidad, en lugar de usar nuestro artefacto <code>IAsyncCollector
				</code> como un acumulador, vamos a hacer que envíe directamente los emails con forme los tenga. Aunque esta no es la implementación recomendada, si que la podremos probar y comprobar que funciona correctamente.
			</p>
			<p>
				para ello, añadiremos un constructor en el que le pasaremos el atributo de <em>binding
				</em>. De este objeto de tipo <code>MailSendAttribute
				</code> vamos a recoger los parámetros de conexión con el servidor SMTP y del objeto <code>MailMessage
				</code> sacaremos los datos necesarios para enviar el email por el servidor ya definido:
			</p>
			<pre class="language-csharp highlight">
<code>private readonly MailSendAttribute _binding;

public MailAsyncCollector(MailSendAttribute binding)
{
    _binding = binding;
    _binding.Autofill();
}

public async Task AddAsync(MailMessage item, CancellationToken cancellationToken = default)
{
    using (var smtp = CreateSmtpClient(_binding))
    {
        var message = CreateMailMessage(item);
        await smtp.SendMailAsync(message);
    }
}

public Task FlushAsync(CancellationToken cancellationToken = default)
{
    return Task.CompletedTask;
}

private static SmtpClient CreateSmtpClient(MailSendAttribute binding)
{
    var smtp = new SmtpClient(binding.Host, binding.Port);
    smtp.EnableSsl = binding.UseSsl;

    if (!string.IsNullOrEmpty(binding.User) && !string.IsNullOrEmpty(binding.Password))
    {
        smtp.Credentials = new NetworkCredential(binding.User, binding.Password);
    }

    return smtp;
}

private static System.Net.Mail.MailMessage CreateMailMessage(MailMessage mail)
{
    var from = new MailAddress(mail.From);
    var to = new MailAddress(mail.To);
    var message = new System.Net.Mail.MailMessage(from, to);
    message.Subject = mail.Subject;
    message.Body = mail.Body;

    return message;
}
				</code>
</pre>
			<p>
				Con estos tres artefactos tendremos definido todo el comportamiento de nuestro <em>custom binding
				</em> que nos ayuda en el envío de emails. Lo que nos falta es hacerle saber al sistema que vamos a extender el comportamiento de las <em>Azure Functions
				</em>, para lo que tendremos que crear un nuevo artefacto que implemente <code>IExtensionConfigProvider
				</code>:
			</p>
			<pre class="language-csharp highlight">
<code>public class MailExtensionConfigProvider : IExtensionConfigProvider
{
    public void Initialize(ExtensionConfigContext context)
    {
        // add json to MailMessage mapper
        context.AddConverter
					<jobject , mailmessage>
						(input => input.ToObject
						<mailmessage>
							());

        // add output custom binding
        context
            .AddBindingRule
							<mailsendattribute>
								()
            .BindToCollector(attr => new MailAsyncCollector(attr));
    }
}
							</mailsendattribute>
						</mailmessage></jobject>
				</code>
</pre>
			<p>
				En este proveedor de configuración indicaremos cómo vamos a mapear un <code>MailMessage
				</code>(por si lo quisiéramos usar con otro lenguaje de programación como JavaScript) y definiremos el <em>out binding
				</em> indicando el atributo y el <code>IAsyncCollector
				</code> que hemos creado.
			</p>
			<p>
				Finalmente, para que nuestro ensamblado registre por defecto el proveedor de configuración que hemos creado, tendremos que declarar una clase tipo <code>Startup
				</code> donde al arrancar el <em>host
				</em> de <em>Azure Functions
				</em> añadiremos nuestra extensión:
			</p>
			<pre class="language-csharp highlight">
<code>using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Hosting;

[assembly: WebJobsStartup(typeof(CustomBindings.Startup))]

namespace CustomBindings
{
    public class Startup : IWebJobsStartup
    {
        public void Configure(IWebJobsBuilder builder)
        {
            builder.AddExtension
					<mailextensionconfigprovider>
						();
        }
    }
}</mailextensionconfigprovider>
				</code>
</pre>
			<h2 id="probando-nuestro-binding">
				Probando nuestro binding
			</h2>
			<p>
				Si queremos ver que todo ha funcionado correctamente, podemos crear un nuevo proyecto de <em>Azure Functions
				</em>. Crearemos una función que responda a una petición HTTP y cuyo nivel de acceso sea <code>Anonymous
				</code>:
			</p>
			<pre class="language-csharp highlight">
<code>[FunctionName("HelloWorld")]
public static IActionResult Run(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = null)] HttpRequest req,
    ILogger log)
{
    log.LogInformation("C# HTTP trigger function processed a request.");

    string name = req.Query["name"];

    return name != null
        ? (ActionResult)new OkObjectResult($"Hello, {name}")
        : new BadRequestObjectResult("Please pass a name on the query string or in the request body");
}
				</code>
</pre>
			<p>
				Ahora añadiremos un parámetro de salida con el binding, indicando el nombre del <code>AppSetting
				</code> de la cadena de conexión. En este caso "SmtpConnectionString". Y en el cuerpo de la función añadiremos los datos necesarios para enviar el email:
			</p>
			<pre class="language-csharp highlight">
<code>[FunctionName("HelloWorld")]
public static IActionResult Run(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = null)] HttpRequest req,
    [MailSend(Connection = "SmtpConnectionString")] out MailMessage message,
    ILogger log)
{
    log.LogInformation("C# HTTP trigger function processed a request.");

    string name = req.Query["name"];

    message = new MailMessage();
    message.From = "noreply@developerro.com";
    message.To = "fernando.escolar@developerro.com";
    message.Subject = "Binding Demo";
    message.Body = $"Deal with it {name}!";


    return name != null
        ? (ActionResult)new OkObjectResult($"Hello, {name}")
        : new BadRequestObjectResult("Please pass a name on the query string or in the request body");
}
				</code>
</pre>
			<p>
				Para finalizar, dentro del archivo <code>local.settings.json
				</code> y en la propiedad <code>Values
				</code>, añadiremos la cadena de conexión con nuestro servidor SMTP:
			</p>
			<pre class="language-json highlight">
<code>"Values": {
    "AzureWebJobsStorage": "",
    "SmtpConnectionString": "Host=smtp.server.com;Port=587;User=myUser;Password=myPassword;UseSsl=true",
    "FUNCTIONS_WORKER_RUNTIME": "dotnet"
  }
				</code>
</pre>
			<p>
				Ahora podemos ejecutar el proyecto, llamar a la función con nuestro browser preferido y ver cómo nos llega un email a la cuenta que hayamos configurado.
			</p>
			<h2 id="conclusiones">
				Conclusiones
			</h2>
			<p>
				Las <em>Azure Functions
				</em> son una herramienta muy potente, que nos permite escribir muy poco código. Cada día que las utilizo me gustan más. Y sabiendo como crear <em>bindings
				</em> personalizados, podemos conseguir centrarnos aun más, tan solo, en la parte más importante de nuestro código.
			</p>
			<p>
				Una excelente manera de convertir 10 líneas de código, que podrían ser una función compartida, en cinco clases. Pero, a la vez, molar que te cagas, por lo guapo que queda meter un atributo decorando una propiedad marcada con <code>out
				</code> y que automágicamente realice una acción más o menos compleja.
			</p>
			<p>
				<img src="/assets/uploads/2019/04/deal-with-it.jpg" alt="Deal with it" />
			</p>
			<p>
				Puedes ver el proyecto completo que hemos utilizado en este artículo en <a href="https://github.com/fernandoescolar/Developerro.AzureFunctions.CustomBindings">este repositorio de Github
				</a>.
			</p>
		</article>
		<section id="share">
			<a href="https://twitter.com/intent/tweet?text=Azure Functions: custom out bindings&url=https://www.developerro.com/2019/04/15/azure-functions-custom-out-bindings" rel="nofollow" target="_blank" title="Share on Twitter">
				<i class="fab fa-twitter">
				</i>
			</a> <a href="https://facebook.com/sharer.php?u=https://www.developerro.com/2019/04/15/azure-functions-custom-out-bindings" rel="nofollow" target="_blank" title="Share on Facebook">
				<i class="fab fa-facebook"></i>
			</a> <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.developerro.com/2019/04/15/azure-functions-custom-out-bindings" rel="nofollow" target="_blank" title="Share on Linkedlin">
				<i class="fab fa-linkedin"></i>
			</a> <a href="http://www.reddit.com/submit?url=https://www.developerro.com/2019/04/15/azure-functions-custom-out-bindings" rel="nofollow" target="_blank" title="Share on Reddit">
				<i class="fab fa-reddit"></i>
			</a> <a href="https://www.buymeacoffee.com/fernandoescolar" rel="nofollow" target="_blank" title="Buy me a beer">
				<i class="fa fa-beer"></i> buy me a beer
			</a>
		</section>
		<section id="related">
			<h2>
				Relacionado (o no)
			</h2>
			<ul>
				<li>
					<a href="/2019/04/23/azure-functions-custom-in-bindings">
						Azure Functions: custom in bindings
					</a> <small>23 abr. 2019
					</small>
				</li>
				<li>
					<a href="/2019/05/02/azure-functions-custom-triggers">
						Azure Functions: custom triggers
					</a> <small>02 may. 2019
					</small>
				</li>
				<li>
					<a href="/2021/03/24/azure-functions-net-5">
						Azure Functions con .NET 5
					</a> <small>24 mar. 2021
					</small>
				</li>
				<li>
					<a href="/2019/03/26/azure-functions-docker">
						Azure Functions con docker
					</a> <small>26 mar. 2019
					</small>
				</li>
				<li>
					<a href="/2019/02/12/azure-functions-typescript">
						Azure Functions con TypeScript
					</a> <small>12 feb. 2019
					</small>
				</li>
			</ul>
		</section>
		<footer>
			<ul>
				<li>
					<a href="mailto:fer.escolar@gmail.com" target="_blank">
						<i class="far fa-envelope">
						</i>
					</a>
				</li>
				<li>
					<a href="https://twitter.com/fernandoescolar" target="_blank">
						<i class="fab fa-twitter">
						</i>
					</a>
				</li>
				<li>
					<a href="https://www.linkedin.com/in/fernandoescolar" target="_blank">
						<i class="fab fa-linkedin">
						</i>
					</a>
				</li>
				<li>
					<a href="https://github.com/fernandoescolar" target="_blank">
						<i class="fab fa-github">
						</i>
					</a>
				</li>
				<li>
					<a href="https://www.buymeacoffee.com/fernandoescolar" target="_blank">
						<i class="fa fa-beer">
						</i>
					</a>
				</li>
			</ul><a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">
				<img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
			</a>
		</footer>
		<dialog id="cookie-notice">
			Nos gustaría usar cookies de terceros para hacer este sitio mejor. <a id="cookie-notice-accept">vale
			</a>
		</dialog>
		<script src="/assets/scripts.js">
		</script>
	</body>
</html>