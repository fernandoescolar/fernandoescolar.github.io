<!DOCTYPE html>
<html lang="es-es">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
		<title>
			Azure Functions: custom in bindings · developerro
		</title>
		<!-- Social Metas -->
		<meta name="description" content="El otro d&#237;a ve&#237;amos c&#243;mo crear custom out bindings para Azure Functions, as&#237; que hoy me he visto obligado a tratar los custom in bindings o de entrada. Para ..." />
		<meta property="og:title" content="Azure Functions: custom in bindings" />
		<meta property="og:type" content="article" />
		<meta property="og:url" content="https://www.developerro.com/2019/04/23/azure-functions-custom-in-bindings" />
		<meta property="og:image" content="https://www.developerro.com/assets/uploads/bg/thunder3.jpg" />
		<meta property="og:description" content="El otro día veíamos cómo crear custom out bindings para Azure Functions, así que hoy me he visto obligado a tratar los custom in bindings o de entrada. Para ..." />
		<meta property="og:site_name" content="developerro" />
		<meta property="og:locale" content="es_es" />
		<meta property="article:modified_time" content="2019-04-23 07:44:11Z" />
		<meta property="article:published_time" content="2019-04-23 07:44:11Z" />
		<meta property="article:author" content="Fernando Escolar" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/24/azure-functions-net-5" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/10/efcore-vs-records" />
		<meta property="og:see_also" content="https://www.developerro.com/2021/03/03/chorra-tip-1-wcd-command" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@fernandoescolar" />
		<meta name="twitter:creator" content="@fernandoescolar" />
		<meta name="twitter:title" content="Azure Functions: custom in bindings" />
		<meta name="twitter:description" content="El otro día veíamos cómo crear custom out bindings para Azure Functions, así que hoy me he visto obligado a tratar los custom in bindings o de entrada. Para ..." />
		<meta name="twitter:image" content="https://www.developerro.com/assets/uploads/bg/thunder3.jpg" />
		<meta name="twitter:url" content="https://www.developerro.com/2019/04/23/azure-functions-custom-in-bindings" />
		<meta name="description" content="El otro día veíamos cómo crear custom out bindings para Azure Functions, así que hoy me he visto obligado a tratar los custom in bindings o de entrada. Para ..." />
		<link rel="alternate" type="application/atom+xml" title="Developerro" href="/atom.xml" />
		<link rel="canonical" href="https://www.developerro.com/2019/04/23/azure-functions-custom-in-bindings" />
		<!-- Icons -->
		<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-144-precomposed.png" />
		<link rel="shortcut icon" href="/assets/favicon.ico" />
		<!-- RSS -->
		<link rel="alternate" type="application/rss+xml" title="Developerro" href="/atom.xml" />
		<!-- Styles -->
		<link href="https://fonts.googleapis.com/css?family=Lato:400,700" rel="stylesheet" type="text/css" />
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" type="text/css" />
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" type="text/css" />
		<link rel="stylesheet" href="/assets/vendor/fontawesome-free/css/all.min.css" />
		<link rel="stylesheet" href="/assets/main.css" />
		<link rel="stylesheet" href="/assets/syntax.css" />
		<!-- Analytics -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=UA-163390000-1">
		</script>
		<script>
			
			    function activateGoogleAnalytics() {
			        window.dataLayer = window.dataLayer || [];
			        function gtag(){dataLayer.push(arguments);}
			        gtag('js', new Date());
			        gtag('config', 'UA-163390000-1');
			    }
			
		</script>
		<style>
			
			    header { background: linear-gradient(to bottom, rgba(228, 225, 216, 0.95) 0%, rgba(172, 65, 66, 0.55) 100%), url(/assets/uploads/bg/thunder3.jpg) center / cover; }
			  
		</style>
	</head>
	<body>
		<nav>
			<i id="hamburger">
			</i> <a href="/">
				<b>
					d</b>eveloperro
			</a>
			<ul>
				<li>
					<a href="/posts">blog
					</a>
				</li>
				<li>
					<a href="/about">
						acerca de
					</a>
				</li>
				<li>
					<a href="/archive">
						archivo
					</a>
				</li>
				<li>
					<a href="/projects">
						oss
					</a>
				</li>
				<li>
					<a href="/search">
						buscar
					</a>
				</li>
				<li>
					<a href="/videos">
						vídeos
					</a>
				</li>
			</ul>
		</nav>
		<header class="post">
			<h1>
				Azure Functions: custom in bindings
			</h1><small>23 abr. 2019 · 9 min. de lectura
			</small>
		</header>
		<article class="post">
			<p>
				El otro día veíamos <a href="/2019/04/15/azure-functions-custom-out-bindings">cómo crear <em>custom out bindings</em> para <em>Azure Functions</em>
				</a>, así que hoy me he visto obligado a tratar los <em>custom in bindings
				</em> o de entrada. Para ello utilizaremos de ejemplo la creación de un <em>binding
				</em> que lea un valor (secret) del servicio Azure Key Vault
				<!--break-->
				.
			</p>
			<p>
				Una de las formas que tenemos de acceder a una cuenta de Key Vault desde dotnet core, es utilizando una cuenta de acceso tipo <em>Service Principal
				</em> (o <em>App Registration
				</em> en el portal de azure) de <em>Azure Active Directory
				</em>. De esta forma tendremos dos parámetros necesarios para recoger un <em>token
				</em> de acceso: un <code>client_id
				</code> y <code>client_secret
				</code>. Entonces, solo tendríamos que utilizar la clase <code>AuthenticationContext
				</code> que encontraremos en el paquete de NuGet <code>Microsoft.IdentityModel.Clients.ActiveDirectory
				</code>, para realizar la petición:
			</p>
			<pre class="language-csharp highlight">
<code>var keyVaultClient = new KeyVaultClient(async (authority, resource, scope) =>
    {
        var authContext = new AuthenticationContext(authority);
        var clientCredential = new ClientCredential(client_id, client_secret);
        var result = await authContext.AcquireTokenAsync(resource, clientCredential).ConfigureAwait(false);
        return result.AccessToken;
    });
				</code>
</pre>
			<p>
				Una vez tenemos instanciado nuestro objeto de tipo <code>KeyVaultClient
				</code>, solo tendremos que realizar una llama a una función que realizará toda la magia por nosotros:
			</p>
			<pre class="language-csharp highlight">
<code>var secret = await keyVaultClient.GetSecretAsync(input.SecretIdentifier, cancellationToken);
Console.WrilteLine(secret.Value);
				</code>
</pre>
			<h2 id="proyecto-de-binding">
				Proyecto de <em>binding
				</em>
			</h2>
			<p>
				Con el fin de desarrollar nuestro <em>custom binding
				</em>, vamos crear un nuevo proyecto de tipo librería de .net standard 2.0. A este proyecto le añadiremos referencias a los siguientes paquetes de NuGet:
			</p>
			<ul>
				<li>
					<code>
						Microsoft.Azure.WebJobs.Extensions
					</code> es donde encontramos los artefactos necesarios para crear nuestra extensión.
				</li>
				<li>
					<code>
						Microsoft.Azure.KeyVault
					</code> es el paquete que contiene el cliente de Azure Key Vault.
				</li>
				<li>
					<code>
						Microsoft.IdentityModel.Clients.ActiveDirectory
					</code> aquí encontraremos las clases necesarias para obtener un token de Azure Active Directory.
				</li>
			</ul>
			<p>
				Después definiremos nuestro atributo de <em>binding
				</em>. Ese que podemos ver en los parámetros de la <em>Azure Function
				</em> entre corchetes. Así que buscaremos un nombre que defina correctamente lo que queremos hacer y le añadiremos "Attribute":
			</p>
			<pre class="language-csharp highlight">
<code>[AttributeUsage(AttributeTargets.Parameter)]
[Binding]
public class KeyVaultSecretAttribute : Attribute
{
    public KeyVaultSecretAttribute()
    {
    }

    public KeyVaultSecretAttribute(string key)
    {
        SecretIdentifier = key;
    }

    public string ClientId { get; set; }

    public string ClientSecret { get; set; }

    public string SecretIdentifier { get; set; }
}
				</code>
</pre>
			<p>
				Con estos parámetros tendríamos todo lo necesario para realizar una petición de un secreto. Además, hemos delimitado el uso de este atributo a parámetros de una función. Y con el decorador <code>Binding
				</code> indicamos que es un atributo que sirve para <em>bindar
				</em> valores usando el SDK de <em>Azure WebJobs
				</em>.
			</p>
			<p>
				Una forma de añadir facilidades a esta clase sería crear una propiedad <code>Connection
				</code> decorada con el atributo <code>AppSetting
				</code>, que indica que es un parámetro que se recoge de las variables de entorno o del archivo <code>local.settings.json
				</code>. La idea es que esta propiedad contenga una cadena de conexión con el formato: "client_id=xxxx;client_secret=yyyyy":
			</p>
			<pre class="language-csharp highlight">
<code>[AppSetting]
public string Connection { get; set; }
				</code>
</pre>
			<p>
				Y podríamos añadirle una serie de métodos para convertir la cadena de conxión en los valores que esperamos y para validarlos:
			</p>
			<pre class="language-csharp highlight">
<code>internal void Validate()
{
    Autofill();
    if (string.IsNullOrEmpty(ClientId) || string.IsNullOrEmpty(ClientSecret))
    {
        throw new ArgumentException("You should specify 'client_id' and 'client_secret' KeyVaultSecret binding parameters.");
    }

    if (string.IsNullOrEmpty(SecretIdentifier))
    {
        throw new ArgumentException("You should specify 'secret identifier' KeyVaultSecret binding parameters.");
    }
}

private void Autofill()
{
    if (string.IsNullOrEmpty(Connection)) return;

    var values = Connection.Split(';').ToDictionary(x => x.Split('=')[0].Trim().ToLowerInvariant(), x => x.Split('=')[1].Trim());

    if (values.ContainsKey("client_id"))
    {
        ClientId = values["client_id"];
    }

    if (values.ContainsKey("client_secret"))
    {
        ClientSecret = values["client_secret"];
    }
}
				</code>
</pre>
			<p>
				Ahora que tenemos definido nuestro <em>binding
				</em>, si queremos usarlo como parámetro de entrada, deberíamos definir un artefacto que implmente la interfaz genérica <code>IConverter&lt;T,S>
				</code> o para métodos asíncronos <code>IAsyncConverter&lt;T,S>
				</code>. Donde:
			</p>
			<ul>
				<li>
					<code>
						T
					</code> es el tipo del atributo que usamos para marcar el <em>binding
					</em>. En este caso <code>KeyVaultSecretAttribute
					</code>.
				</li>
				<li>
					<code>
						S
					</code>es el tipo de objeto que va a devolder. En <em>Azure Key Vault
					</em> un secreto se almacena en formato de cadena de texto, por lo que será un <code>string
					</code>.
				</li>
			</ul>
			<pre class="language-csharp highlight">
<code>public class KeyVaultSecretAsyncConverter : IAsyncConverter
					<keyvaultsecretattribute , string>
						{
    public async Task
						<string>
							ConvertAsync(KeyVaultSecretAttribute input)
    {
    }
}
						</string></keyvaultsecretattribute>
				</code>
</pre>
			<p>
				La implementación basada en el código que indicamos al inicio de este documento sería:
			</p>
			<pre class="language-csharp highlight">
<code>public async Task
					<string>
						ConvertAsync(KeyVaultSecretAttribute input, CancellationToken cancellationToken)
{
    input.Validate();
    using (var client = CreateClient(input.ClientId, input.ClientSecret))
    {
        var secret = await client.GetSecretAsync(input.SecretIdentifier, cancellationToken);
        return secret.Value;
    }
}

private static KeyVaultClient CreateClient(string clientId, string clientSecret)
{
    return new KeyVaultClient(async (authority, resource, scope) =>
    {
        var authContext = new AuthenticationContext(authority);
        var clientCredential = new ClientCredential(clientId, clientSecret);
        var result = await authContext.AcquireTokenAsync(resource, clientCredential).ConfigureAwait(false);
        if (result == null)
        {
            throw new InvalidOperationException("Failed to obtain the JWT token");
        }

        return result.AccessToken;
    });
}</string>
				</code>
</pre>
			<p>
				Donde validaríamos la información que almacena nuestro <em>binding
				</em> y acto seguido realizaríamos la petición al cliente, obteniendo así el secreto.
			</p>
			<p>
				Con estos dos artefactos ya tendríamos definido todo el comportamiento de nuestro <em>custom binding
				</em> que leerá valores de una cuenta de <em>Azure Key Vault
				</em>. Lo que nos falta es hacerle saber al sistema que vamos a extender el comportamiento de las <em>Azure Functions
				</em>, para lo que tendremos que crear un nuevo artefacto que implemente <code>IExtensionConfigProvider
				</code>:
			</p>
			<pre class="language-csharp highlight">
<code>public class KeyVaultExtensionConfigProvider : IExtensionConfigProvider
{
    public void Initialize(ExtensionConfigContext context)
    {
        var rule = context.AddBindingRule
					<keyvaultsecretattribute>
						();
        rule.AddValidator(ValidateKeyVaultSecretAttribute);
        rule.BindToInput(new KeyVaultSecretAsyncConverter());
    }

    private static void ValidateKeyVaultSecretAttribute(KeyVaultSecretAttribute attribute, Type parameterType)
    {
        attribute.Validate();
    }
}</keyvaultsecretattribute>
				</code>
</pre>
			<p>
				En este proveedor de configuración indicaremos que vamos a crear un nuevo <em>binding
				</em> usando el atributo <code>KeyVaultSecretAttribute
				</code>. A esta nueva regla le añadiremos una validación que comprobará que los datos del atributo son correctos. Y finalmente, le indicaremos que es un <em>binding
				</em> de tipo entrada con la función <code>BindToInput
				</code>.
			</p>
			<p>
				Cuando indicamos que es un <em>binding
				</em> de entrada de datos, hemos visto que tenemos la variante de devolver una instancia de un objeto de tipo <code>IConverter
				</code>o <code>IAsyncConverter
				</code>, pero en realidad también admite una función. A mi, personalmente, me parece más elegante definir un "converter", pero cuando estamos hablando de poca lógica, es posible que con una simple lambda quede resuelto.
			</p>
			<p>
				Para terminar y que nuestro ensamblado registre por defecto el proveedor de configuración que hemos creado, tendremos que declarar una clase tipo <code>Startup
				</code> donde al arrancar el <em>host
				</em> de <em>Azure Functions
				</em> añadiremos nuestra extensión:
			</p>
			<pre class="language-csharp highlight">
<code>using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Hosting;

[assembly: WebJobsStartup(typeof(CustomBindings.Startup))]

namespace CustomBindings
{
    public class Startup : IWebJobsStartup
    {
        public void Configure(IWebJobsBuilder builder)
        {
            builder.AddExtension
					<keyvaultextensionconfigprovider>
						();
        }
    }
}</keyvaultextensionconfigprovider>
				</code>
</pre>
			<h2 id="probando-nuestro-binding">
				Probando nuestro binding
			</h2>
			<p>
				Si queremos ver que todo ha funcionado correctamente, podemos crear un nuevo proyecto de <em>Azure Functions
				</em>. Crearemos una función que responda a una petición HTTP y cuyo nivel de acceso sea <code>Anonymous
				</code>:
			</p>
			<pre class="language-csharp highlight">
<code>[FunctionName("TestKeyVaultSecret")]
public static IActionResult TestKeyVaultSecret(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = null)] HttpRequest req,
    ILogger log)
{
}
				</code>
</pre>
			<p>
				Ahora añadiremos un parámetro de tipo <code>string
				</code> y lo decoraremos con el atributo <code>KeyVaultSecret
				</code>. Para que esto funcione, especificaremos la URL que identifica nuestro secreto e indicaremos que la conexión que va a usar está en el <code>AppSetting
				</code> con nombre "KeyVaultConnectionString":
			</p>
			<pre class="language-csharp highlight">
<code>[FunctionName("TestKeyVaultSecret")]
public static IActionResult TestKeyVaultSecret(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = null)] HttpRequest req,
    [KeyVaultSecret("https://my.vault.azure.net/secrets/MyKey", Connection = "KeyVaultConnectionString")] string secret,
    ILogger log)
{
    log.LogInformation("C# HTTP trigger function processed a request.");
    return new OkObjectResult($"Your secret: {secret}");
}
				</code>
</pre>
			<p>
				Para finalizar, dentro del archivo <code>local.settings.json
				</code> y en la propiedad <code>Values
				</code>, añadiremos la cadena de conexión con los datos del <em>Service Principal
				</em> al que dimos acceso:
			</p>
			<pre class="language-json highlight">
<code>"Values": {
    "AzureWebJobsStorage": "",
    "KeyVaultConnectionString": "client_id=xxxx;client_secret=yyyyy",
    "FUNCTIONS_WORKER_RUNTIME": "dotnet"
  }
				</code>
</pre>
			<p>
				Ahora podemos ejecutar el proyecto, llamar a la función con nuestro browser preferido y ver cómo imprime por pantalla el valor almacenado en un secreto de una cuenta de <em>Azure Key Vault
				</em>.
			</p>
			<h2 id="conclusiones">
				Conclusiones
			</h2>
			<p>
				Pues lo mismo del otro día pero con <em>in
				</em> en lugar de <em>out
				</em>.
			</p>
			<p>
				<img src="/assets/uploads/2019/04/deal-with-it.jpg" alt="Deal with it" />
			</p>
			<p>
				Puedes ver el proyecto completo que hemos utilizado en este artículo en <a href="https://github.com/fernandoescolar/Developerro.AzureFunctions.CustomBindings">este repositorio de Github
				</a>.
			</p>
		</article>
		<section id="share">
			<a href="https://twitter.com/intent/tweet?text=Azure Functions: custom in bindings&url=https://www.developerro.com/2019/04/23/azure-functions-custom-in-bindings" rel="nofollow" target="_blank" title="Share on Twitter">
				<i class="fab fa-twitter">
				</i>
			</a> <a href="https://facebook.com/sharer.php?u=https://www.developerro.com/2019/04/23/azure-functions-custom-in-bindings" rel="nofollow" target="_blank" title="Share on Facebook">
				<i class="fab fa-facebook"></i>
			</a> <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.developerro.com/2019/04/23/azure-functions-custom-in-bindings" rel="nofollow" target="_blank" title="Share on Linkedlin">
				<i class="fab fa-linkedin"></i>
			</a> <a href="http://www.reddit.com/submit?url=https://www.developerro.com/2019/04/23/azure-functions-custom-in-bindings" rel="nofollow" target="_blank" title="Share on Reddit">
				<i class="fab fa-reddit"></i>
			</a> <a href="https://www.buymeacoffee.com/fernandoescolar" rel="nofollow" target="_blank" title="Buy me a beer">
				<i class="fa fa-beer"></i> buy me a beer
			</a>
		</section>
		<section id="related">
			<h2>
				Relacionado (o no)
			</h2>
			<ul>
				<li>
					<a href="/2019/04/15/azure-functions-custom-out-bindings">
						Azure Functions: custom out bindings
					</a> <small>15 abr. 2019
					</small>
				</li>
				<li>
					<a href="/2019/05/02/azure-functions-custom-triggers">
						Azure Functions: custom triggers
					</a> <small>02 may. 2019
					</small>
				</li>
				<li>
					<a href="/2021/03/24/azure-functions-net-5">
						Azure Functions con .NET 5
					</a> <small>24 mar. 2021
					</small>
				</li>
				<li>
					<a href="/2019/03/26/azure-functions-docker">
						Azure Functions con docker
					</a> <small>26 mar. 2019
					</small>
				</li>
				<li>
					<a href="/2019/02/12/azure-functions-typescript">
						Azure Functions con TypeScript
					</a> <small>12 feb. 2019
					</small>
				</li>
			</ul>
		</section>
		<footer>
			<ul>
				<li>
					<a href="mailto:fer.escolar@gmail.com" target="_blank">
						<i class="far fa-envelope">
						</i>
					</a>
				</li>
				<li>
					<a href="https://twitter.com/fernandoescolar" target="_blank">
						<i class="fab fa-twitter">
						</i>
					</a>
				</li>
				<li>
					<a href="https://www.linkedin.com/in/fernandoescolar" target="_blank">
						<i class="fab fa-linkedin">
						</i>
					</a>
				</li>
				<li>
					<a href="https://github.com/fernandoescolar" target="_blank">
						<i class="fab fa-github">
						</i>
					</a>
				</li>
				<li>
					<a href="https://www.buymeacoffee.com/fernandoescolar" target="_blank">
						<i class="fa fa-beer">
						</i>
					</a>
				</li>
			</ul><a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">
				<img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
			</a>
		</footer>
		<dialog id="cookie-notice">
			Nos gustaría usar cookies de terceros para hacer este sitio mejor. <a id="cookie-notice-accept">vale
			</a>
		</dialog>
		<script src="/assets/scripts.js">
		</script>
	</body>
</html>