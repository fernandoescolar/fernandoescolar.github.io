---
published: false
---

---
title: Roslyn
author: fernandoescolar
post_date: 2016-02-09 21:30:03
layout: post
---
El número de resultados que encuentras al buscar "Roslyn" es de 9-13 millones. Está claro que está de moda. Pero ¿qué es Roslyn? ¿y por qué debería importarme?
<!--break-->

Roslyn es un compilador de .Net. Es un analizador semántico de código. Es un binder. Es un refactorizador. Es open source. Es el segundo advenimiento del desarrollo. Emite IL. Está integrado con Visual Studio. Pero funciona en cualquier plataforma. Es como el famoso "jamón" al que [cantaban Los Berzas](https://www.youtube.com/watch?v=PMxdM38QxUY "Los Berzas - Yo amo el jamón").

Cuando escucho la palabra "Roslyn" me viene a la mente La Hora Chanante. Pienso en Joaquín Reyes repitiendo esta palabra. Primero más agudo. Luego más grave. Y para terminar alargando las vocales mientras agudiza el tono.

Últimamente he estado jugando un poco con Roslyn. Sobre todo porque el próximo 24 de febrero tengo una charla junto con mi compañero [Juan Bacardit](https://twitter.com/juanbacardit "Juan Bacardit") en la [DotNet Spain Conference 2016](https://www.desarrollaconmicrosoft.com/Dotnetspain2016 "DotNet Spain Conference 2016") en Madrid. Y he aquí los resultados de mis experimentos:

Una vez nos hemos instalado [Roslyn en Visual Studio](https://github.com/dotnet/roslyn/wiki/Getting-Started-on-Visual-Studio-2015 "Instalar Roslyn en Visual Studio"), las [plantillas y el SDK](https://visualstudiogallery.msdn.microsoft.com/2ddb7240-5249-4c8c-969e-5d05823bcb89 "Instalar plantillas y el SDK de Roslyn"); es muy fácil empezar a trabajar. Tan solo tenemos que elegir una de esas plantillas y ya tendremos un ejemplo de lo que podemos hacer:

![Roslyn templates]({{site.baseurl}}/_drafts/templates.png)

## Como hacer tu IDE más lento
La plantilla que más fascina es la de "Analyzer with Code Fix (NuGet+VSIX)". Es un todo en uno para enlentecer tu entorno. Automáticamente te crea una regla de análisis de código y un refacor para corregirlo. Como resultado de compilarlo: un paquete NuGet y un VSIX. Todo listo para ser instalado en todos los Visual Studio del mundo.

Pero el analizador de demostración no me gusta. Así que vamos a implementar el nuestro propio. La idea es que cada vez que detectemos un nombre que NO contenga palabrotas, nos avise. Así que he añadido este archivo archivos:

```csharp
public static class BadWordService
{
    public static readonly string[] BadWords = new string[] { "shit", "crap", "dick", "asshole", "motherfucker", "bastard", "prick", "jerk", "bitch", "damn", "fuck", "hell" };

    public static bool ContainsBadWords(this string source)
    {
        return BadWords.Any(s => source.ToLowerInvariant().Contains(s.ToLowerInvariant()));
    }

    public static string AddBadWord(this string source)
    {
        var r = new Random();
        var word = BadWords[r.Next(0, BadWords.Length - 1)];
        return string.Format("{0}{1}{2}", source, char.ToUpperInvariant(word[0]), word.Substring(1));
    }
}
´´´

Y he modificado el código del analyzer a algo como esto:

```csharp
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class BadWordsRulesAnalyzer : DiagnosticAnalyzer
{
    public const string DiagnosticId = "BadWordsRules";
    private const string Title = "No Bad Words in Name";
    private const string MessageFormat = "There is no Bad Word in this name: '{0}'";
    private const string Description = "There is no Bad Word in this name";
    private const string Category = "Naming";

    private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, isEnabledByDefault: true, description: Description);

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }

    public override void Initialize(AnalysisContext context)
    {
        context.RegisterSymbolAction(AnalyzeBadWordsInSymbolName, SymbolKind.NamedType);
    }

    private static void AnalyzeBadWordsInSymbolName(SymbolAnalysisContext context)
    {
        var namedTypeSymbol = context.Symbol;
        var name = namedTypeSymbol.Name;
        AnalyzeName(context, name, namedTypeSymbol.Locations[0]);
    }
    
    private static void AnalyzeName(SymbolAnalysisContext context, string name, Location location)
    {
        if (!name.ContainsBadWords())
        {
            var diagnostic = Diagnostic.Create(Rule, location, name);
            context.ReportDiagnostic(diagnostic);
        }
    }
}
´´´

Al ejecutar se nos abrirá una nueva instancia de Visual Studio. Si abrimos un proyecto, veremos que nos marcará los nombres de las clases que no contengan palabras mal sonantes. 

Y a partir de aquí es donde viene lo bueno. Podemos hacer que el sistema nos proponga cómo corregir estos errores. Esto lo podríamos hacer modificando el archivo "CodeFix":

```csharp
[ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(BadWordsRulesCodeFixProvider)), Shared]
public class BadWordsRulesCodeFixProvider : CodeFixProvider
{
    private const string title = "Add Bad Word";

    public sealed override ImmutableArray<string> FixableDiagnosticIds
    {
        get { return ImmutableArray.Create(BadWordsRulesAnalyzer.DiagnosticId); }
    }

    public sealed override FixAllProvider GetFixAllProvider()
    {
        return WellKnownFixAllProviders.BatchFixer;
    }

    public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context)
    {
        var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);
        var diagnostic = context.Diagnostics.First();
        var diagnosticSpan = diagnostic.Location.SourceSpan;
        var token = root.FindToken(diagnosticSpan.Start);

        context.RegisterCodeFix(
            CodeAction.Create(
                title: title,
                createChangedSolution: c => AddBadWord(context.Document, token, c),
                equivalenceKey: title),
            diagnostic);
    }

    private static Task<Solution> AddBadWord(Document document, SyntaxToken token, CancellationToken cancellationToken)
    {
        var newName = token.Text.AddBadWord();
        return RenameAsync(document, token, cancellationToken, newName);
    }

    private static async Task<Solution> RenameAsync(Document document, SyntaxToken token, CancellationToken cancellationToken, string newName)
    {
        var semanticModel = await document.GetSemanticModelAsync(cancellationToken);
        var typeSymbol = semanticModel.GetDeclaredSymbol(token.Parent, cancellationToken);

        var originalSolution = document.Project.Solution;
        var optionSet = originalSolution.Workspace.Options;
        var newSolution = await Renamer.RenameSymbolAsync(document.Project.Solution, typeSymbol, newName, optionSet, cancellationToken).ConfigureAwait(false);

        return newSolution;
    }
}
´´´

Si ejecutamos este último código nos propondrá poner una palabra mal sonante al final de cada nombre de clase. Y al hacerlo, buscará una aleatoría y la añadira. Haciendo el correspondiente refactor en todo el proyecto.

![Ejemplo Analyzer y Code Fix]({{site.baseurl}}/_drafts/badwords-analyzer.png)


## Como hacer lo mismo de antes con la mitad de trabajo

## Mi propio analizador out of the box

## Rompiéndose la cabeza


