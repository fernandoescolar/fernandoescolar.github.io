---
published: false
---
La nueva versión de c# se acerca. Será la número 7 ya. C# 7 lo llaman. Aunque posiblemente le acompañará una versión de .Net Framework 4.X.X. Ó quizá una dotNet Core 1.X. De cualquier forma no podemos ignorarlo. Pero no es mi intención realizar un aburrido recorrido sobre sus novedosas características. El objetivo del post es realizar un aburrido recorrido sobre sus novedosas características, y ponerles nota.<!--break-->

El problema es que puede resultar un poco simplista usar el manido sistema de una escala de valores del 1 al 10. Las nuevas características de c# se merecen un sistema de puntuación que nos aporte más granularidad del detalle...

Recuerdo que en un capitulo de la serie _How I Met Your Mother_ nuestro estimado Barney Stinson exponía un sistema de calificación llamado _escala sexi-loca_.

![escala sexy loca]({{site.baseurl}}/public/uploads/2016/11/hot_crazy.jpg)

Así que he decidido coger prestado este sistema. La idea es que:

- en el eje vertical encontraremos cómo de buena resulta la característica para el lenguaje

- y en el horizontal cómo de loco nos parece que es implementarla como la han implementado

Determinaremos que toda puntuación que se encuentra por encima de _la diagonal Vicky Mendoza_ es una buena característica. Y lo que se encuentre por debajo... ejem...

![escala useful-crazy]({{site.baseurl}}/public/uploads/2016/11/useful-crazy.png)


> Nota: la diagonal Vicky Mendoza es la recta formada por la función x = y.


# Variables "out"

Si alguna vez hemos trabajado con este tipo de variables sabremos lo engorroso que resulta tenerlas que declarar antes de llamar a la función que las asigna. En c# 7 esto deja de ser un problema. Ahora las podemos declarar _inline_. Además después de declararlas de esta forma, están disponibles para su uso en el _scope_ principal:

```csharp
public void PrintCoordinates(Point p)
{
    p.GetCoordinates(out int x, out int y);
    Console.WriteLine($"({x}, {y})");
}
```

Y como además conocemos el tipo que se va a devolver, ahora se permite el uso de "var" en sus declaraciones:

```csharp
public void PrintCoordinates(Point p)
{
    p.GetCoordinates(out var x, out var y);
    Console.WriteLine($"({x}, {y})");
}
```

> Valoración:

> Useful = **9**

> Crazy = **2**

# Pattern matching

No sé si alguno habrá trabajado con F# alguna vez. Si lo has hecho, te sonará esta funcionalidad. Si no, estás de suerte: ahora ya nada más que tu ignorancia impedirá que programes usando el paradigma funcional.

Pattern matching es un patrón de programación que nos ayuda a determinar si un objeto cumple unas características determindas. Algo así como un montón de _if's_ muy potentes, o un super _switch_.


## En un "if"

La mejor forma de ver qué es pattern matching es un ejemplo:

```csharp
public void PrintStars(object o)
{
    if (o is null) return;     // determina si un objeto es nulo
    if (!(o is int i)) return; // determina si un objeto es un int y lo asigna a "i"
    WriteLine(new string('*', i)); // note que el scope de "i" no es solo el "if"
}
```

Una forma de usarlo que parece un poco magia negra sería al transformar un "object" en un "int":

```csharp
if (o is int i || (o is string s && int.TryParse(s, out i)) { /* use i */ }
```

## En un "switch"

Siempre me ha hecho gracia cuando hablas sobre que "switch is evil", que algún iluminado salta con un "en mi código nunca uso 'switch'". Pero luego vas a su código y tiene una cantidad de _if's_ encadenados que da miedo. Un _if_ es como un _switch_. Por lo que en este tipo de clausulas, también podremos usar pattern matching: 

```csharp
switch(shape)
{
    case Circle c: // determina si es de tipo 'Circle' y lo asigna a 'c'
        WriteLine($"circle with radius {c.Radius}");
        break;
    case Rectangle s when (s.Length == s.Height): // determina si es un cuadrado
        WriteLine($"{s.Length} x {s.Height} square");
        break;
    case Rectangle r: // si es un rectángulo
        WriteLine($"{r.Length} x {r.Height} rectangle");
        break;
    default: // si no tenemos ni pajolera idea de qué es
        WriteLine("<unknown shape>");
        break;
    case null: // o si es 'null'
        throw new ArgumentNullException(nameof(shape));
}
```

Aquí tendremos que tener en cuenta varias cosas que son importantes:

- El orden de lo _case_ importa.

- La clausula _default_ siempre será evaluada la última. Aunque esté rodeada de _case_'s.

- El _case null_ del final si que es posible que se ejecute.

- La variable que se declara dentro de un _case_ solo está disponible en el scope de ese _case_, no en el de todo el switch.

> Valoración:

> Useful = **8**

> Crazy = **7**

# Tuplas

Cuando necesitas que una función devuelva más de una variable y te parece que eso del encapsulamiento de la programación orientada a objetos es una pamplina, solo puedes hacer alguna _ñapa_:

- Usar parámetros "out" (pero no va con async/await)

- Usar el objeto System.Tuple<...> como valor a devolver por la función (meh!)

- Usar métodos anónimos (no sirve para static)

Pero tranquilo. C# 7 trae la solución para todos aquellos programadores que piensan que la cohesión es una fuerza física.

Las tuplas están aquí y han venido para quedarse. Esto es una forma más o menos elegante de declarar objetos anónimos al vuelo sin necesidad de definir nombres, pero sí tipos. Un ejemplo sería si quisieramos que una función nos devolviera 3 _string's_:

```csharp
(string, string, string) LookupName(long id) // devuelce una tupla formada por 3 strings
{
    ... // realizamos nuestra movida con las variables first, middle y last
    return (first, middle, last); // y devolvemos la tupla de 3 strings
}
```

La eficiencia de esto es incuestionable. El saber qué demonios devuelve la función es otra cosa...

Vamos ahora a consumir esta función:

```csharp
var names = LookupName(id);
Console.WriteLine($"found {names.Item1} {names.Item3}.");
```

Como podéis ver solo hace falta que llamemos a las propiedades desde _Item1_ hasta _ItemN_ de nuestra tupla. Está claro que este código puede confundir más que ayudar. Así que también se permite poner nombre a los diferentes objetos que devolvemos en una tupla (y menos mal):

```csharp
(string first, string middle, string last) LookupName(long id) // tuplas con nombres de elementos
```

Para devolver una tupla con nombres, se nos permite usarlos en su creación:

```csharp
    return (first: first, middle: middle, last: last); // creando una tupla usando los nombres
```

De tal forma que al llamarla, el código resultante será más intuitivo:

```csharp
var names = LookupName(id);
WriteLine($"found {names.first} {names.last}.");
```

Una tupla es para el sistema un tipo de valor. Sus elementos son públicos y mutables. Además, si comparamos dos tuplas con los mismos elementos, podemos determinar si son iguales o no. 

## Deconstruction

Another way to consume tuples is to deconstruct them. A deconstructing declaration is a syntax for splitting a tuple (or other value) into its parts and assigning those parts individually to fresh variables:

```csharp
(string first, string middle, string last) = LookupName(id1); // deconstructing declaration
Console.WriteLine($"found {first} {last}.");
```

In a deconstructing declaration you can use var for the individual variables declared:

```csharp
(var first, var middle, var last) = LookupName(id1); // var inside
```

Or even put a single var outside of the parentheses as an abbreviation:

```csharp
var (first, middle, last) = LookupName(id1); // var outside
```

You can also deconstruct into existing variables with a deconstructing assignment:

```csharp
(first, middle, last) = LookupName(id2); // deconstructing assignment
```

Deconstruction is not just for tuples. Any type can be deconstructed, as long as it has an (instance or extension) deconstructor method of the form:

```csharp
public void Deconstruct(out T1 x1, ..., out Tn xn) { ... }
```

The out parameters constitute the values that result from the deconstruction.

(Why does it use out parameters instead of returning a tuple? That is so that you can have multiple overloads for different numbers of values).

```csharp
class Point
{
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y) { X = x; Y = y; }
    public void Deconstruct(out int x, out int y) { x = X; y = Y; }
}

(var myX, var myY) = GetPoint(); // calls Deconstruct(out myX, out myY);
```

It will be a common pattern to have constructors and deconstructors be “symmetric” in this way.

# Wildcards

El nuevo sistema de wildcards nos permite usar el símbolo asterisco para no tener que definir algo que no queremos. Por ejemplo, si tenemos una variable "out" que no necesitamos, podemos usarlo: 

```csharp
p.GetCoordinates(out int x, out *); // solo me preocupa la 'x'
```

O en el caso de usar tuplas, también podemos usarlo:

```csharp
(var myX, *) = GetPoint(); // I only care about myX
```

> Valoración:
Useful = 4
Crazy = 8


# Local functions

Sometimes a helper function only makes sense inside of a single method that uses it. You can now declare such functions inside other function bodies as a local function:

```csharp
public int Fibonacci(int x)
{
    if (x < 0) throw new ArgumentException("Less negativity please!", nameof(x));
    return Fib(x).current;

    (int current, int previous) Fib(int i)
    {
        if (i == 0) return (1, 0);
        var (p, pp) = Fib(i - 1);
        return (p + pp, p);
    }
}
```

Parameters and local variables from the enclosing scope are available inside of a local function, just as they are in lambda expressions.

As an example, methods implemented as iterators commonly need a non-iterator wrapper method for eagerly checking the arguments at the time of the call. (The iterator itself doesn’t start running until MoveNext is called). Local functions are perfect for this scenario:

```csharp
public IEnumerable<T> Filter<T>(IEnumerable<T> source, Func<T, bool> filter)
{
    if (source == null) throw new ArgumentNullException(nameof(source));
    if (filter == null) throw new ArgumentNullException(nameof(filter));

    return Iterator();

    IEnumerable<T> Iterator()
    {
        foreach (var element in source) 
        {
            if (filter(element)) { yield return element; }
        }
    }
}
```

If Iterator had been a private method next to Filter, it would have been available for other members to accidentally use directly (without argument checking). Also, it would have needed to take all the same arguments as Filter instead of having them just be in scope.

>Note: In Preview 4, local functions must be declared before they are called. This restriction will be loosened, so that they can be called as soon as local variables they read from are definitely assigned.

# Literal improvements

C# 7.0 allows _ to occur as a digit separator inside number literals:

```csharp
var d = 123_456;
var x = 0xAB_CD_EF;
```

You can put them wherever you want between digits, to improve readability. They have no effect on the value.

Also, C# 7.0 introduces binary literals, so that you can specify bit patterns directly instead of having to know hexadecimal notation by heart.

```csharp
var b = 0b1010_1011_1100_1101_1110_1111;
```

# Ref returns and locals

Just like you can pass things by reference (with the ref modifier) in C#, you can now return them by reference, and also store them by reference in local variables.

```csharp
public ref int Find(int number, int[] numbers)
{
    for (int i = 0; i < numbers.Length; i++)
    {
        if (numbers[i] == number) 
        {
            return ref numbers[i]; // return the storage location, not the value
        }
    }
    throw new IndexOutOfRangeException($"{nameof(number)} not found");
}

int[] array = { 1, 15, -39, 0, 7, 14, -12 };
ref int place = ref Find(7, array); // aliases 7's place in the array
place = 9; // replaces 7 with 9 in the array
WriteLine(array[4]); // prints 9
```

This is useful for passing around placeholders into big data structures. For instance, a game might hold its data in a big preallocated array of structs (to avoid garbage collection pauses). Methods can now return a reference directly to such a struct, through which the caller can read and modify it.

There are some restrictions to ensure that this is safe:

- You can only return refs that are “safe to return”: Ones that were passed to you, and ones that point into fields in objects.

- Ref locals are initialized to a certain storage location, and cannot be mutated to point to another.

# Generalized async return types

Up until now, async methods in C# must either return void, Task or Task<T>. C# 7.0 allows other types to be defined in such a way that they can be returned from an async method.

For instance we plan to have a ValueTask<T> struct type. It is built to prevent the allocation of a Task<T> object in cases where the result of the async operation is already available at the time of awaiting. For many async scenarios where buffering is involved for example, this can drastically reduce the number of allocations and lead to significant performance gains.

There are many other ways that you can imagine custom “task-like” types being useful. It won’t be straightforward to create them correctly, so we don’t expect most people to roll their own, but it is likely that they will start to show up in frameworks and APIs, and callers can then just return and await them the way they do Tasks today.

> Note: Generalized async return types are not yet available in Preview 4.

# More expression bodied members

Expression bodied methods, properties etc. are a big hit in C# 6.0, but we didn’t allow them in all kinds of members. C# 7.0 adds accessors, constructors and finalizers to the list of things that can have expression bodies:

```csharp
class Person
{
    private static ConcurrentDictionary<int, string> names = new ConcurrentDictionary<int, string>();
    private int id = GetId();

    public Person(string name) => names.TryAdd(id, name); // constructors
    ~Person() => names.TryRemove(id, out *);              // destructors
    public string Name
    {
        get => names[id];                                 // getters
        set => names[id] = value;                         // setters
    }
}
```

> Note: These additional kinds of expression-bodied members do not yet work in Preview 4.

This is an example of a feature that was contributed by the community, not the Microsoft C# compiler team. Yay, open source!

# Throw expressions

It is easy to throw an exception in the middle of an expression: just call a method that does it for you! But in C# 7.0 we are directly allowing throw as an expression in certain places:

```csharp
class Person
{
    public string Name { get; }
    public Person(string name) => Name = name ?? throw new ArgumentNullException(name);
    public string GetFirstName()
    {
        var parts = Name.Split(" ");
        return (parts.Length > 0) ? parts[0] : throw new InvalidOperationException("No name!");
    }
    public string GetLastName() => throw new NotImplementedException();
}
```

> Note: Throw expressions do not yet work in Preview 4.

